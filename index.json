[{"categories":["生活杂记"],"content":"博客重启咯，写写之前这段时间和最近。 从阿里云三个月实习归来，结识了超棒的团队，学到了不少东西，可惜产出的技术文档啥的搬不回来 在杭州的每一天都感觉快乐又充实 八月份的时候一边上班一边面试，也没刷题，没想到居然面面过，拿到了微信增值、美团优选、字节视频架构的offer，这样想今年的面试通过率就是100%了（去年0%） 看到自己做的互动直播样板间SDK成功被客户（哈罗摩托）上线，直播火爆至极，好有成绩感！ 等阿里的offer等了好久好久终于等到了 内推好难，打了半天广告只有一份简历到手。给三个比较熟的老师的实验室打了广告，学长学姐来点简历吧 从初中到长沙上学开始，过了九年没有在老家过中秋了，今年终于回来了，和家人们一起好热闹，明年如果在阿里一定要多搞一盒月饼回家，集团的月饼挺好吃 今天完成了博客的搬家，hugo生成的速度很快，感觉很不错 立个flag，明年年前：flutter、WebRTC和Go 希望下个月offer开奖多点米吧！来点好运！ ","date":"2021-09-22","objectID":"/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/:0:0","tags":["随便写写"],"title":"简简单单写一段","uri":"/%E5%8D%9A%E5%AE%A2%E6%90%AC%E5%AE%B6/"},{"categories":[],"content":"你好 我是一个来自湖南的小伙 现在在华科读计算机大四 这个博客主要使用来整理输出平时学习的知识，偶尔写点生活感想 如果你想联系我，我的微信号是JMJcoding ","date":"2021-09-22","objectID":"/about/:0:1","tags":[],"title":"关于我","uri":"/about/"},{"categories":["学习笔记"],"content":"Java 学习笔记 ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"基本程序设计 标准输入/输出流 System.out：标准输出流类OutputStream的对象 System.in：标准输入流类InputStream的对象 Scanner类（java.util.Scanner） Scanner scanner = new Scanner(System.in); //构造函数Scanner的参数类型也可为java.io.File //这是Scanner就从文件而不是标准输入流读取数据 double d = scanner.nextDouble( ); 方法： nextByte( )、nextShort( )、nextInt( ) nextLong( )、nextFloat( )、nextDouble( ) next( ) 读入一个字符串 如果输入的不是一个合法的值，这些语句会抛出异常 标识符 命名规则 标识符是由字母、数字、下划线( )、美元符号($)组成的字符序列，必须以字母、下划线(_)或美元符号($)开头，不能以数字开头，不能是保留字，可以为任意长度，但编译通常只接受前128字符。 变量声明 ​ datatype variableName \u003c= expression\u003e; 常量声明 ​ final datatype CONSTANT_NAME = value; ​ //常量的声明和初始化必须同时完成 赋值语句 ​ variable = expression; 数据类型 整数 byte 8位带符号整数 short 16位带符号整数 int 32位带符号整数 long 64位带符号整数 浮点数 float 32位浮点数 double 64位浮点数 范围：byte \u003c char \u003c short \u003c int \u003c long \u003c float \u003c double 整数字面值 以0开头表示八进制，如035；以0x或0X开头表示十六进制，如0x1D,0X1d；以1-9开头表示十进制，如29 后缀字母：以l或L结尾表示long类型，如29L；无后缀表示int类型。 浮点数字面值 浮点数是包含小数点的十进制数，后跟可选的指数部分。如1.8e1、18E2 后缀字母：以d或D结尾或者无后缀表示double类型；以f或F结尾表示float类型 ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:1","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"条件分支语句与运算符 if-else: if跟的括号中必须是boolean表达式 switch：判断表达式和case常量的类型只能是char, byte, short, int, Character, Byte, Short, Integer, String, enum type（JLS 13） 支持？：语句 除赋值运算符之外的二元运算符都是左结合的。 赋值运算符和?:运算符是右结合的。 ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:2","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"数学函数 Math类，位于java.lang.Math中 数学函数都是静态方法 Math类中定义了常用的数学变量如PI与E 常用的数学函数包括 三角函数： sin、cos、tan、toRadians、toDegrees、asin、acos、atan，除了角度转弧度函数toRadians，其他函数的参数都是以弧度为单位的角度； 指数函数：exp、log、log10、pow、sqrt； 取整函数：ceil（向上取整，返回双精度整数）、floor（向下取整，返回双精度整数）、rint（返回最近整数，若与两个整数相等则优先返回偶数，返回也是双精度）、round（由参数x的精度返回x+0.5的向下取整的单精度/双精度） 生成随机数：Math.random()，返回[0.0,1.0)之间的double类型随机数 生成随机字符： (char)(ch1+(int)(Math.rabdom()*(ch2-ch1+1))) ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:3","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"字符和字符串 字符串 java.lang.String表示一个固定长度的字符序列，实例化后其内容不能改。 构造函数 长度(length) 获取字符(charAt) 连接(concat) 截取(substring) 比较(equals, equalsIngnoeCase, compareTo, startWith，endWith, regionMatch) 转换(toLowerCase, toUpperCase, trim, replace) 查找(indexOf, lastIndexOf) 字符串和数组间转换(getChars, toCharArray), 字符串和数字间转换(valueOf) String类对象创建后不可变 由于字符串是不可变的，为了提高效率和节省内存，Java中的字符串字面值维护在字符串常量池中）。这样的字符串称为规范字符串(canonical string)。 可以使用字符串对象（假设内容为Welcome to Java）的intern方法返回规范化字符串。intern方法会在字符串常量池中找是否已存在”Welcome to Java”,如果有返回其地址。如果没有，在池中添加“Welcome to java”再返回地址。即intern方法一定返回一个指向常量池里的字符串对象引用。 String s = \"Welcome to Java\"; String s1 = new String(\"Welcome to Java\"); String s2 = s1.intern(); String s3 = \"Welcome to Java\"; System.out.println(s1 == s); //false System.out.println(s2 == s); //true System.out.println(s3 == s); //true 字符串的比较 equals方法用于比较两个字符串是否包含相同的内容（字符序列）: 两个字符串内容相同，返回true 两个字符串内容不同，返回false 比较字符串内容不能直接比较二个引用变量，比较二个引用变量只是判断这二个引用变量是否指向同一个对象（如s1 == s2） equalsIgnoreCase忽略大小写比较内容是否相同 regionMatch比较部分内容是否相同 startsWith判断是否以某个字符串开始 endsWith判断是否以某个字符串结束 compareTo方法用于比较两个字符串的大小，即第一个不同字符的差值（字典序）。s1.compareTo(s2)的返回值: 当两个字符串相同时，返回０ 当s1按字典排序在s2之前，返回小于０的值 当s1按字典排序在s2之后，返回大于０的值 字符串长度和获取单个字符 调用length( )方法可以获取字符串的长度（不是字节数，因为java里的一个char占2两个字节） charAt(index)方法可以获取指定位置的字符。index必须在0到s.length()-1之间。 连接字符串 concat方法用于连接两个字符串。例如： String s3 = s1.concat(s2); 使用加号(+)连接两个字符串。例如： String s3 = s1 + s2; s1 + s2 + s3 等价于s1.concat(s2).concat(s3) 连接操作返回一个新的字符串：因为String类型的实例内容不可修改。 截取字串 substring用于截取字符串的一部分，返回新字符串，它有两个重载版本： public String substring(int beginIndex, int endIndex)返回字符串的子串。子串从beginIndex开始，直到endIndex-1。 public String substring(int beginIndex)返回字符串的子串。子串从beginIndex开始，直到字符串的结尾。 字符串转换 toLowerCase将字符串转换成小写形式，得到新串（对中文字符无效） toUpperCase将字符串转换成大写形式，得到新串（对中文字符无效） trim删除两端的空格，得到新串 replace字符替换，得到新串 查找字符或字符串 indexOf返回字符串中字符或字符串匹配的位置，返回-1表示未找到，如果有多个位置出现，那么会返回第一次出现的位置。 字符数组和字符串间的转换 toCharArray将字符串转换成字符数组 String s = “Java”; char[ ] charArray = s.toCharArray( );// charArray.length=4 将字符数组转换成字符串 使用String的构造函数，可同时初始化 new String(new char[ ] {‘J’,‘a’,‘v’,‘a’} ); 使用valueOf方法：静态方法 String.valueOf( new char[ ] {‘J’,‘a’,‘v’,‘a’} ); String.valueOf(2.34); //2.34转“2.34” valueOf方法将基本数据类型转换为字符串。例如 String s1 = String.valueOf(1.0); //“１.0” String s2 = String.valueOf(true); //“true” 字符串转换为基本类型：利用包装类 Double.parseDouble(str) Integer.parseInt(str) Boolean.parseBoolean(str) StringBuilder与StringBuffer StringBuilder与StringBuffer(final类）初始化后还可以修改字符串。 StringBuffer修改缓冲区的方法是同步（synchronized）的，更适合多线程环境。 StringBuilder线程不安全，与StringBuffer工作机制类似。 由于可修改字符串， StringBuilder 与StringBuffer 增加了String类没有的一些函数，例如：append、insert、delete、replace、reverse、setCharAt等。 仅以StringBuilder为例： StringBuilder stringMy=new StringBuilder( ); StringMy.append(“Welcome to”); StringMy.append(“ Java”); StringBuffer用于处理可变内容的字符串，与普通String类的相似操作返回新串不同，修改它会直接修改这个串本身，具有以下方法： append方法在字符串的结尾追加数据 insert方法在指定位置上插入数据 reverse方法翻转字符串 replace方法替换字符 toString方法返回String对象 capacity方法返回缓冲区的容量 length方法返回缓冲区中字符的个数 setLength方法设置缓冲区的长度 charAt方法返回指定位置的字符 setCharAt方法设置指定位置的字符 注意println不能接受StringBuffer类型，需要加toString()来实现，但是不写也会隐式完成转换。 格式化控制台输出 JDK1.5开始提供了格式化控制台输出方法 System.out.printf(format, item1, item2, …); //格式化字符串，后面跟要打印的变量列表 格式化字符串 String.format(format, item1, item2, …); //返回一个格式化好了的String 格式描述符：%[argument_index$] [flags][width][.precision]conversion，其中 可选的 argument_index 是一个十进制整数，用于表明参数在参数列表中的位置。第一个参数由 “1$” 引用，第二个参数由 “2$” 引用 conversion：应该如何格式化参数的字符 %b 布尔值 %c 字符 %d 十进制整数 %f 浮点数 %e 科学计数法 %s 字符串 String s = String.format(“格式$：%1$d,%2$s”, 99,“abc”); //结果”格式$：99，abc“ ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:4","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"方法 方法的定义 方法(method)是为执行一个复杂操作组合在一起的语句集合。一个类中可以声明多个方法。 语法：采用BNF范式 (Backus-Naur Form，巴科斯范式)描述（用来描述计算机语言语法的符号集） 方法签名(Method Signature)指方法名称+形参列表（不含返回类型）。一个类中不能包含方法签名相同的多个方法。 方法头中声明的变量称为形参(formal parameter)。 当调用方法时，可向形参传递一个值，这个值称为实参(actual parameter / argument)。形参可以使用final进行修饰，表示方法内部不允许修改该参数(类似C++的const)。 形参不允许有默认值，最后一个可为变长参数（可用…或数组定义）。 方法里不允许定义static局部变量。 方法可以有一个返回值(return value)。如果方法没有返回值，返回值类型为void，但构造函数没有返回值（不能加void）。 调用方法 声明方法只给出方法的定义。要执行方法，必须调用(call/invoke)方法。 当调用方法时，程序控制权从调用者转移至被调用的方法。当执行return语句或到达方法结尾时，程序控制权转移至调用者。 方法分类的静态方法和实例方法 实例方法：必须用对象名调用（对象名：指向对象的引用变量名） 静态方法：可用类名调用，也可用对象名调用 ​ 调用当前类中的静态方法：可直接用“方法名”，也可用”类名.方法名“（推荐） ​ 调用当前类中的实例方法可用“方法名” 或 “this.方法名”调用（推荐）。 ​ 调用其它类中的静态方法：用“类名.方法名”或“对象名.方法名” ​ 调用其它类的的实例方法：必须用对象名.方法名 ​ 子类实例函数里用” super.方法名“调用父类实例方法。（super是引用，通过super只能调用实例方法） ​ 所有静态方法提倡用”类名.方法名“调用（这样可读性好，一看到类名，就知道调用的是静态方法）。 ​ public class A { public static void staticMethodOfA1(){ } public void instancMethodOfA1() { } public void instancMethodOfA2(){ //调用实例方法必须通过对象引用 instancMethodOfA1(); //调用当前类的另一个实例方法，实际上和下面语句等价 this.instancMethodOfA1(); //推荐用this.调用当前类的另一个实例方法，this就是指向当前对象的引用 //调用静态方法 A.staticMethodOfA1(); //推荐通过类名调用静态方法 staticMethodOfA1(); //如果调用当前类的静态方法，类名可以省略 B.staticMethodOfB(); //调用另外一个类的静态方法必须用类名 //调用另外一个类的实例方法必须通过指向另外一个类的对象的引用 new B().instancMethodOfB(); } } public class B{ public static void staticMethodOfB() {} public void instancMethodOfB() { } } 调用堆栈 系统中专门有一个部分用来压栈调用的数据。每当调用一个方法时，系统将该方法参数、局部变量存储在一个内存区域中，这个内存区域称为调用堆栈(call stack)。当方法结束返回到调用者时，系统自动释放相应的调用栈。 方法的参数传递 如果方法声明中包含形参，调用方法时，必须提供实参。 实参的类型必须与形参的类型兼容：如子类实参可传递给父类形参。 实参顺序必须与形参的顺序一致。 当调用方法时，基本数据类型是传值调用，即实参值的副本被传递给方法的形参。方法内部对形参的修改不影响实参值。(Call by value) 对象类型的参数是引用调用。（Call by reference） 方法的重载 方法重载(overloading)是指方法名称相同，但形参列表不同的方法。仅返回类型不同的方法不是合法的重载。一个类中可以包含多个重载的方法（同名的方法可以重载多个版本）。 形参列表不同指参数个数不同，或至少一个参数类型不同 当调用方法时，Java编译器会根据实参的个数和类型寻找最合适的方法进行调用。 调用时匹配成功的方法可能多于一个，则会产生编译二义性错误，称为歧义调用(ambiguous invocation)。 //方法重载示例 public class TestMethodOverloading { /** Return the max between two int values */ public static int max(int num1, int num2) { return (num1 \u003e num2) ？num1:num2; } /** Return the max between two double values */ public static double max(double num1, double num2) { return (num1 \u003e num2) ？num1:num2; } /** Return the max among three double values */ public static double max(double num1, double num2, double num3) { return max(max(num1, num2), num3); } } 方法局部变量的作用域 方法内部声明的变量称为局部变量(local variable)。方法的形参等同于局部变量。 局部变量的作用域(scope)指程序中可以使用该变量的部分。 局部变量的作用域从它的声明处开始，直到包含该变量的程序块{}结束。局部变量在使用前必须先赋值。局部变量的生命期和其作用域相同,因为{}结束时，局部变量出栈。 在方法中，可以在不同的非嵌套程序块中以相同的名称多次声明局部变量。但不能在嵌套的块中以相同的名称多次声明局部变量。 在for语句的初始动作部分声明的变量，作用域是整个循环体。在for语句循环体中声明的变量，作用域从变量声明开始到循环体结束。 ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:5","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"数组 数组的基础知识 数组(array)是相同类型变量集合(这里的集合不是JDK的Collection） 数组类型的变量是引用相同类型变量集合的引用变量 数组元素本身也可以是引用变量。 多维数组只是数组的数组，故数组元素也可能是引用类型变量 凡使用new创建数组后，内存单元都初始化为0或null 任何实例化的数组都是Object的子类。数组引用变量声明语法： datatype[ ] arrayRefVar; //提倡的写法：类型在前，[ ]在后 例如： double[ ] myList; //这时myList为null 或者 datatype arrayRefVar[ ]; 例如： double myList[ ]; double [ ] a[ ]; //double[][] a; 数组变量是引用类型的变量，声明数组引用变量并不分配数组内存空间。必须通过new实例化数组来分配数组内存空间。 使用new操作符创建数组。 arrayRefVar = new datatype[arraySize]; 例如： myList = new double[10]; //这时才分配内存 声明和创建在一条语句中。 datatype[ ] arrayRefVar= new datatype[arraySize]； 或者 datatype arrayRefVar[ ] = new datatype[arraySize]； 例如： double[ ] myList = new double[10]; 或者 double myList[ ] = new double[10]; 新创建的数组对象，其元素根据类型被设置为默认的初始值（实际上都为0）。 数值类型为0 字符类型为’\\u0000’ //u后面为十六进制，必须4位写满 布尔类型为false 引用类型为null 数组可以在声明后的花括号中提供初始值。 double[ ] myList = {1.9, 2.9, 3, 3.5}//可以将int转化为double类型，这时不用指定维度size 或者 double[ ] myList; myList = new double[ ] {1.9, 2, 3.4, 3.5} //可以将int转化为double类型，声明和创建不在一条语句时，不能直接用{ }来初始化 数组的大小在创建这个数组之后不能被改变。用.length来访问长度。 数组元素通过索引进行访问。元素的索引从0开始，范围从0到length-1。 数组的复制 直接使用赋值语句不能实现数组复制，结果是两个数组引用变量指向同一个数组对象（浅拷贝赋值）。 复制数组的方法 使用循环来复制每个元素 使用System.arraycopy方法：两个数组都预先实例化了 调用数组的clone方法复制：被复制的数组变量可以没有实例化 数组传递给方法 可以将数组变量作为实参传递给方法。 基本数据类型传递的是实际值的拷贝，修改形参，不影响实参。 数组引用变量传递的是对象的引用，修改形参引用的数组，将改变实参引用的数组。 也可以从方法中返回数组，返回的也是引用。 （引用类型的实参传递给形参后，实参、形参指向同一个对象。但是，对于String类、基本数据类型的包装类型的实参传递给形参，形参变了不会导致实参变化。这是因为对于String、Integer这样内容不可改变的对象，当对其赋值时实际上创建了一个新的对象，这是为了设计上保持和未包装的类型的特性一致。） 可变长参数列表 可以把类型相同但个数可变的参数传递给方法。方法中的可变长参数声明如下 typeName … parameterName 在方法声明中，指定类型后面跟省略号 只能给方法指定一个可变长参数，同时该参数必须是最后一个参数 Java将可变长参数当数组看待，通过length属性得到可变参数的个数 print(String… args){ //可看作String [ ]args\u000bfor(String temp:args)\u000bSystem.out.println(temp); System.out.println(args.length);\u000b} 调用该方法 print(“hello”,“lisy”); Arrays类 java.util.Arrays类包括各种静态方法，其中实现了数组的排序和查找 排序 double[ ] numbers={6.0, 4.4, 1.9, 2.9}; java.util.Arrays.sort(numbers); //注意直接在原数组排序 二分查找 int[ ] list={2, 4, 7, 10, 11, 45, 50}; int index = java.util.Arrays.binarySearch(list, 11); Arrays和String是常用的两个值得研究的类。 命令行参数 可以从命令行向java程序传递参数。参数以空格分隔，如果参数本身包含空格，用双引号括起来。格式： java 类名 参数１ 参数２ … 例如 java TestMain “First number” alpha 53 命令行参数将传递给main方法的args参数。args是一个字符串数组，可以通过数组下标访问每个参数。 public static void main(String[ ] args) 注意Java的命令行参数不包括类名， args.length==3 可变长参数用…定义。args是一个字符串数组，可以定义为可变长参数。String … args可以当成String[ ] args数组使用。 public static void main(String … args) //也可以作为启动函数 注意在定义重载函数时，编译器认为String[] args和String … args类型相同 ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:6","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"类和对象 类和对象的UML表示 对象(object)是现实世界中可识别(不一定可见)的实体，对象具有状态和行为。其状态是其属性的当前值，其行为是一系列方法，这些方法可改变对象的状态。对象：学生、按钮、政府等。 类(class)定义或封装同类对象共有的属性和方法，即将同类型对象共有的属性和行为抽象出来形成类的定义。 例如要开发学生管理系统，根据应用需求，我们发现所有学生的以下共有属性和行为需要管理 属性：学号、姓名、性别、所在学院、年级、班级 行为：考试、上课、完成作业 因此形成类的定义：Class Student{ … },属性作为数据成员，行为作为方法成员 同一类型的对象有相同的属性和方法，但每个对象的属性值不同。 类(类型简称)是对象的模板、蓝图。对象是类的实例。 UML：广泛应用的面向对象设计的的建模工具，但独立于任何具体程序设计语言。作为一种建模语言，UML有严格的语法和语义规范。对于复杂系统，先用UML建模，再编写代码。UML工具会自动把模型编译成Java(C++）源码（方法体是空的） UML采用一组图形符号来描述软件模型，这些图形符号简单、直观和规范。所描述的软件模型，可以直观地理解和阅读，由于具有规范性，所以能够保证模型的准确、一致。 定义类并用new创建其对象 new根据传参自动选择调用的构造函数 注意：如果创建对象数组，则其成员缺省值为null，这和C++自动创建数组成员对象不一样。 Circle[] circleArray = new Circle[10]; //这时没有构造Circle对象，只是构造数组 for(int i = 0; i \u003c circleArray.length; i++) { circleArray[i] = new Circle( ); //这时才构造Circle对象，可使用有参构造函数 } 构造器（constructor） 无返回类型，名字同类名，用于初始化对象。 注意JAVA如果在前面加void，即定义void className(…)，被认为是普通方法而不是构造器方法 无法被显式调用，只在new时被自动执行。 必须是实例方法（无static），可为公有、保护、私有和包级权限。 类的变量为引用(相当于C指针)，指向实例化好的对象。 Circle c2=new Circle(5.0);//调用时必须有括弧，可带参初始化 缺省构造函数(同C++) 如果类未定义任何构造函数，编译器会自动提供一个不带参数的默认构造函数。 如果已自定义构造函数，则不会提供默认构造函数。 Java没有析构函数，但垃圾自动回收之前会自动调用finalize( )，可以覆盖定义该函数（但是finalize调用时机程序员无法控制）。 对象访问、向方法传递对象引用 访问对象：通过对象引用访问。JVM维护每个对象的引用计数器，只要引用计数器为0，该对象会由JVM自动回收。通过对象引用，可以 访问对象的实例变量(非静态数据字段)：c2.radius。 调用对象的实例方法：c2.findArea( )。通过c2调用实例方法时，c2引用会传给实例方法里的this引用。 也可访问静态成员和静态方法（不推荐。推荐用类名） 在实例方法中有个this引用，代表当前对象(引用当前对象：相当于指针)，因此在实例方法里，可以用this引用访问当前对象成员 this.radius this.findArea( )； 在构造器中调用构造器（通过”this(构造器参数)的方式“调用 ），须防止递归调用 不能对this进行赋值 匿名对象也可访问实例(或静态)成员 与基本数据类型变量不同：引用变量表示数据的内存单元地址或存储位置。 基本类型变量存储的是基本类型的值。 数组和类是引用类型变量。它引用了内存里的数组或对象。每个对象（数组）有引用计数。 引用类型变量存储的是对象的引用。当变量未引用任何对象或未实例化时，它是值为null。 一个对象的引用计数=0时被自动回收。 对象作为方法参数时与传递数组一样，传递对象实际是传递对象的引用。 Java无类似C++的\u0026或C#的ref来修饰方法参数，只能靠形参的声明类型来区分是传值还是传引用，因此一定要注意区分。 包 包是一组相关的类和接口的集合。将类和接口分装在不同的包中，可以避免重名类的冲突，更有效地管理众多的类和接口。因此package就是C++里的namespace 包的定义通过关键字package来实现的 ，package语句的一般形式： package 包名; package语句必须出现在.java文件第一行，前面不能有注释行也不能有空白行，该.java文件里定义的所有内容（类、接口、枚举）都属于package所定义的包里。如果.java文件第一行没有package语句，则该文件定义的所有内容位于default包（缺省名字空间），但不推荐。 不同.java文件里的内容都可以属于同一个包，只要它们第一条package语句的包名相同 package本质上就是C++里的namespace，因此 在同一个package里不能定义同名的标识符（类名，接口名，枚举名）。例如一个类名和一个接口名不能相同 如果要使用其它包里标识符，有二个办法： 用完全限定名，例如要调用java.util包里的Arrays类的sort方法： java.util.Arrays.sort(list)； 在package语句后面，先引入要使用其它包里的标识符，再使用： import java.util.Arrays; //或者： import java.util.*; Arrays.sort(list)； import语句可以有多条，分别引入多个包里的名字 使用二种import的区别 单类型导入(single type import)：导入包里一个具体的标识符，如 import java.util.Arrays; 按需类型导入(type import on demand)：并非导入一个包里的所有类，只是按需导入 import java.util.*; 这二种导入的区别类似C++里二种使用名字空间方式的区别 单类型导入：把导入的标识符引入到当前.java文件，因此当前文件里不能定义同名的标识符，类似C++里 using nm::id; 把名字空间nm的名字id引入到当前代码处 按需导入：不是把包里的标识符都引入到当前.java文件，只是使包里名字都可见，使得我们要使用引入包里的名字时可以不用使用完全限定名，因此在当前.java文件里可以定义与引入包里同名的标识符。但二义性只有当名字被使用时才被检测到。类似于C++里的using nm; package p1; public class A { } //方法1 package p2; //单类型导入，把p1.A引入到当前域 import p1.A; //这个时候当前文件里不能定义A， //下面语句编译报错 public class A { } //方法二 package p2; import p1.*; //按需导入，没有马上把p1.A引入到当前域 //因此当前文件里可以定义A public class A { public static void main(String[] args){ A a1 = new A(); //这时A是p2.A System.out.println(a1 instanceof p2.A); //true //当前域已经定义了A，因此要想使用package p1里的A， //只能用完全限定名 p1.A a2 = new p1.A(); } } //如果出现了名字冲突，要用完全限定名消除冲突 包除了起到名字空间的作用外，还有个很重要的作用：提供了package一级的访问权限控制（在Java里，成员访问控制权限除了公有、保护、私有，还多了包一级的访问控制；类的访问控制除了public外，也多了包一级的访问控制） 包的命名习惯: 将Internet域名作为包名 （但级别顺序相反），这样的好处是避免包名的重复 org.apache.tools.zip cn.edu.hust.cs.javacourse.ch1 如果所有程序员都遵循这种包命名的约定，包名重复的可能性就非常小 面向对象的封装性要求最好把实例成员变量设为私有的或保护的 同时为私有、保护的实例成员变量提供公有的get和set方法。get和set方法遵循JavaBean的命名规范，即getPropertyName、setPropertyName 实例(或静态)的变量、常量和方法 class Circle { private double radius; /** 私有静态变量，记录当前内存里被实例化的Circle对象个数*/ private static int numberOfObjects = 0; public Circle() { radius = 1.0; numberOfObjects++; } public Circle(double newRadius) { radius = newRadius; numberOfObjects++; } public double getRadius() {return radius;} public void setRadius(double newRadius) { radius = newRadius;} /** 公有静态方法，获取私有静态变量内容*/ public static int getNumberOfObjects() {return numberOfObjects;} ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:7","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"继承和多态 类继承、子类和父类的isA关系 语法 class ClassName extends Superclass { class body } //如果父类是Object，则extends部分可省略（前面的示例代码里，每个的父类都是Object） 如果class C1 extends C2，则称C1为子类(subclass)，C2为父类(superclass)。 子类继承了父类中可访问的数据和方法，子类也可添加新的数据和方法， 子类不继承父类的构造函数。 一个类只能有一个直接父类（Java不支持多重继承，因为Java的设计者认为没有必要）。 Java的继承都是公有继承，因此被继承的就是父类，继承的类就是子类。因此父类的成员如果被继承到子类，访问权限不变 因此子类和父类是ISA关系：一个子类对象ISA父类对象。 初始化块是Java类中可以出现的第四种成员（前三种包括属性、方法、构造函数），分为实例初始化块和静态初始化块。 实例初始化模块（instance initialization block，IIB）是一个用大括号括住的语句块，直接嵌套于类体中，不在方法内。 它的作用就像把它放在了类中每个构造方法的最开始位置。用于初始化对象。实例初始化块先于构造函数执行 作用： 如果多个构造方法共享一段代码，并且每个构造方法不会调用其他构造方法，那么可以把这段公共代码放在初始化模块中。 一个类可以有多个初始化模块，模块按照在类中出现的顺序执行； 实例初始化模块还有个作用是可以截获异常； 实例初始化模块最重要的作用是当我们需要写一个内部匿名类时：匿名类不可能有构造函数，这时可以用实例初始化块来初始化数据成员； 实例初始化模块只有在创建类的实例时才会调用。 定义并初始化类的实例变量等价于实例初始化块：private int id = 0； 一个类可以有多个实例初始化块，对象被实例化时，模块按照在类中出现的顺序执行，构造函数最后运行。 静态初始化模块是由static修饰的初始化模块{}，只能访问类的静态成员，并且在JVM的Class Loader将类装入内存时调用。（类的装入和类的实例化是两个不同步骤，首先是将类装入内存，然后再实例化类的对象）。 在类体里直接定义静态变量相当于静态初始化块 如果class C1 extends C2，则称C1为子类(subclass)，C2为父类(superclass)。 子类继承了父类中可访问的数据和方法，子类也可添加新的数据和方法， 子类不继承父类的构造函数。 一个类只能有一个直接父类（Java不支持多重继承，因为Java的设计者认为没有必要）。 Java的继承都是公有继承，因此被继承的就是父类，继承的类就是子类。因此父类的成员如果被继承到子类，访问权限不变 因此子类和父类是ISA关系：一个子类对象ISA父类对象 初始化模块执行顺序： 第一次使用类时装入类 如果父类没装入则首先装入父类，这是个递归的过程，直到继承链上所有祖先类全部装入 装入一个类时，类的静态数据成员和静态初始化模块按它们在类中出现的顺序执行 实例化类的对象 首先构造父类对象，这是个递归过程，直到继承链上所有祖先类的对象构造好 构造一个类的对象时，按在类中出现的顺序执行实例数据成员的初始化及实例初始化模块 执行构造函数函数体 super关键字 利用super可以显式调用父类的构造函数 super(parametersopt)调用父类的的构造函数。 必须是子类构造函数的第1条且仅1条语句(先构造父类)。 如果子类构造函数中没有显式地调用父类的构造函数，那么将自动调用父类不带参数的构造函数。 父类的构造函数在子类构造函数之前执行。 访问父类的成员（包括静态和实例成员） super不能用于静态上下文（即静态方法和静态初始化块里不能使用super），this也不能用于静态上下文 super.data（如果父类属性在子类可访问，包括实例和静态） super.method(parameters)（如果父类方法在子类可访问，包括实例和静态） 不能使用super.super.p()这样的super链 如果子类中没有显式地调用父类的构造函数，那么将自动调用父类不带参数的构造函数，因为编译器会偷偷地在子类构造函数第一条语句前加上super() ；在任何情况下，构造一个类的实例时，会沿着继承链调用所有父类的构造方法，这叫构造方法链。 如果一个类自定义了构造函数（不管有无参数），编译器不会自动加上无参构造函数。 如果一个类没定义任何构造函数，编译器会自动地加上无参构造函数。 编译器在为子类添加无参构造函数时，函数体里会用super( )默认调用父类的无参构造函数，如果找不到父类无参构造函数，则编译器为子类添加无参构造函数失败，编译报错。 如果一个类定义了带参数的构造函数，一定别忘了定义一个无参的构造函数，原因是：由于系统不会再自动加上无参构造函数，就造成该类没有无参构造函数 如果父类没有无参构造函数，那么子类构造函数里若调用父类无参构造函数就会编译出错。 实例方法覆盖 如果子类重新定义了从父类中继承的实例方法，称为方法覆盖(method override)。 仅当父类方法在子类里是可访问的，该实例方法才能被子类覆盖，即父类私有实例方法不能被子类覆盖，父类实例私有方法自动视为final的。 静态方法不能被覆盖，如果静态方法在子类中重新定义，那么父类方法将被隐藏。 覆盖特性：一旦父类中的实例方法被子类覆盖，同时用父类型的引用变量引用了子类对象，这时不能通过这个父类型引用变量去访问被覆盖的父类方法(即这时被覆盖的父类方法不可再被发现)。因为实例方法具有多态性（晚期绑定） 在子类函数中可以使用super调用被覆盖的父类方法。 隐藏特性：指父类的变量（实例变量、静态变量）和静态方法在子类被重新定义，但由于类的变量（实例和静态）和静态方法没有多态性，因此通过父类型引用变量访问的一定是父类变量、静态方法(即被隐藏的可再发现)。 方法覆盖的哲学涵义：子对象当然可以修改父类的行为（生物进化除了遗传，还有变异） class A{ public void m() { System.out.println(\"A's m\"); } public static void s() { System.out.println(\"A's s\"); } } class B extends A{ //覆盖父类实例方法 public void m() { System.out.println(\"B's m\"); } //隐藏父类静态方法 public static void s() { System.out.println(\"B's s\"); } } public class OverrideDemo { public static void main(String[] args) { A o = new B();//父类型变量引用子类对象 o.m();//由于父类实例方法m被子类覆盖，o运行时指向B类对象，由于多态性，执行的是B的m o.s(); //由于s是静态方法，没有多态性，编译器编译时对象o的声明类型是A，所以执行的是A的s } } 引用变量o有二个类型：声明类型A，实际运行时类型B判断o.s()执行的是哪个函数按照o的声明类型，因为静态函数s没有多态性， 函数入口地址在编译时就确定（早期绑定），而编译时所有变量的类型都按声明类型。 判断o.m()执行的是哪个函数按照o的实际运行类型，在运行时按照o指向的实际类型B来重新计算函数入口地址（晚期绑定。多态性），因此调用的是B的m。 因此一旦引用变量o指向了B类型对象（A o = new B()），o.m()调用的永远是B的m，再也无法通过o调用A的m，哪怕 强制转换都不行： ((A)o).m();调用的还是B的m这就是前面所说的不能再发现。 Object中的方法 java.lang.Object类是所有类的祖先类。如果一个类在声明时没有指定父类，那么这个类的父类是Object类。 它提供方法如toString、equals、getClass、clone、finalize。前3个为公有，后2个为保护。getClass为final（用于泛型和反射机制，禁止覆盖）。 equals方法:用于测试两个对象是否相等。Object类的默认实现是比较两个对象引用是否引用同一个对象。 toString方法：返回代表这个对象的字符串。Object类的默认实现是返回由类名、@和hashCode组成。 Circle circle = new Circle(); circle.toString();//Circle@15037e5，如果Circle没有覆盖toString Object的toString方法提供的信息不是很有用。因此通常子类应该覆盖该方法，提供更有意义的信息 equals用于判断一个对象同另一个对象的所有成员内容是否相等。覆盖时应考虑： 对基本类型数值成员。直接使用==判断即可。 对引用类型变量成员。则需要对这些变量成员调用equals判断，不能用==。 覆盖equals函数，最好同时覆盖hashCode()方法，该方法返回对象的hashCode值。 需要对比的时候，首先用hashCode去对比，如果hashCode不一样，则表示这两个对象肯定不相等（也就是不必再用equals()去再对比了）,如果hashCode相同，此时再用equals()比，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！ 覆盖equals函数，首","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:8","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"抽象类和接口 抽象类 子类继承父类后，通常会添加新的属性和方法。因此沿着继承链越往下继承的子类其属性和方法越来越具体。相反，越上层的祖先类其实现越抽象，甚至无法给出具体实现。一个长方形图形有面积，但其祖先类GeometricObject的getArea()方法可能没法给出具体实现，这时可以定义成抽象方法。 Java可定义不含方法体的方法，其方法体由子类根据具体情况实现，这样的方法称为抽象方法(abstract method)，包含抽象方法的类必须是抽象类(abstract class)。 抽象类和抽象方法的声明必须加上abstract关键字。 抽象方法的意义：加给子类的一个约束。例如Circle类和Rectangle类计算面积必须使用父类规定的函数签名。这样可以充分利用多态特性使得代码变得更通用 abstract class GeometricObject{ //属性和方法定义 public abstract double getArea(); public abstract double getPerimeter(); } /*包含抽象方法的类必须是抽象类 抽象类和抽象方法必须用abstract关键字修饰 没有包含抽象方法的类也可以定义成抽象类*/ class Circle extends GeometricObject{ //新的属性 @Override public double getArea() { //给出具体实现 } @Override public double getPerimeter() { //给出具体实现 } } 抽象方法：使用abstract定义的方法或者接口中定义的方法（接口中定义的方法自动是抽象的，可以省略abstract）。 一个类C如果满足下面的任一条件，则该类包含抽象方法且是抽象类： 类C显式地包含一个抽象方法的声明； 类C的父类中声明的抽象方法未在类C中实现； 类C所实现的接口中有的方法在类C里没有实现 只要类C有一个未实现的方法（自己定义的或继承的），就是抽象类 但是，一个不包含任何抽象方法的类，也可以定义成抽象类 抽象类不能被实例化 只有实例方法可以声明为抽象方法（Java里所有实例方法自动是虚函数，因此Java里没有virtual关键字）。 抽象类不能被实例化，即不能用new关键字创建对象（即new 右边的类型不能是抽象类）。 但是抽象类可以作为变量声明类型、方法参数类型、方法返回类型 为什么？因为一个抽象类型引用变量可以指向具体子类的对象 抽象类可以定义构造函数，并可以被子类调用。 抽象类可以定义变量、非抽象方法并被子类使用 抽象类的父类可以是具体类：自己引入了抽象方法。例如，具体类Object是所有类的祖先父类。 接口 接口是公共静态常量和公共抽象实例方法的集合。接口是能力、规范、协议的反映。 接口不是类：(1)不能定义构造函数；(2)接口之间可以多继承，类可implements多个接口。(3)和抽象类一样，不能new一个接口 语法： [modifier] interface interfaceName { constant_declaration* abstract_method_declaration* } 接口中的所有数据字段隐含为public static final 接口体中的所有方法隐含为public abstract 接口用法： 可以在能够使用任何其他数据类型的地方使用接口。 接口类型属于引用类型，接口类型的变量可以是： 空引用(null) 引用实现了该接口的类的实例 接口需要具体的类去实现。类实现接口的语法 除非类为abstract,所有接口的成员方法必须被实现 一个类只能继承一个父类，但可以实现多个接口，多个接口以“，”分开。 [modifier] class className [extends superclass][implements interfaceNameList ] { member_declaration* } 除非类为abstract,所有接口的成员方法必须被实现 一个类只能继承一个父类，但可以实现多个接口，多个接口以“，”分开。 接口不是类（Java支持单继承类），一个接口可以继承多个接口。 语法 如果接口声明中提供了extends子句，那么该接口就继承了父接口的方法和常量。被继承的接口称为声明接口的直接父接口。 任何实现该接口的类，必须实现该接口继承的其他接口。 [modifier] interface interfaceName [extends interfaceNameList] { declaration* } 如果接口声明中提供了extends子句，那么该接口就继承了父接口的方法和常量。被继承的接口称为声明接口的直接父接口。 任何实现该接口的类，必须实现该接口继承的其他接口。 有时需要比较二个对象，但不同类型对象的比较具有不同的含义，因此Java定义了Comparable接口。 因此，任何需要比较对象的类，都要实现该接口。 Cloneable、Runnable、Comparable等接口均在包java.lang中： CompareTo判断this对象相对于给定对象o的顺序，当this对象小于、等于或大于给定对象o时，分别返回负数、0或正数 package java.lang; public interface Comparable{ public int compareTo(Object o); } CompareTo判断this对象相对于给定对象o的顺序，当this对象小于、等于或大于给定对象o时，分别返回负数、0或正数 有了Comparable接口，我们可以实现很通用的类来比较对象，例如实现一个从两个对象中找出最大者的方法。 public class Max{ public static Comparable findMax (Comparable o1, Comparable o2){ if(o1.CompareTo(o2) \u003e 0 ) return o1; else return o2; } } 注意findMax方法的参数类型和返回类型都是Comparable（只要是实现了Comparable接口的对象都可以传进来。 Comparable接口描述了可以比较大小的能力，一个类实现了这个接口，意味着这个类的对象直接可以比较大小） Max.findMax与Comparable接口的具体实现子类无关。只要是实现了Comparable接口的具体类的二个对象（注意是同一个具体类的二个对象）传进来， Max.findMax都能工作。这就是接口的好处。（程序存在的问题：如果是2个实现了Comparable接口的不同具体类对象传进来怎么办？最好通过泛型解决） 另外要注意的是：o1.CompareTo(o2)调用是动态绑定（多态）（调用具体子类对象的CompareTo方法） Java定义了Cloneable接口，任何想克隆的类必须实现该接口，同时覆盖从Object类继承的clone方法，并将访问属性改为public Cloneable接口为空接口(未定义任何函数)，其定义为 package java.lang; public interface Cloneable { } 空接口称为标记接口(markup interface) 空接口有什么作用？唯一目的允许你用instanceof检查对象的类型： if(obj instanceof Cloneable)… 接口 抽象类 多重继承 一个接口可以继承多个接口 一个类只能继承（extends)一个抽象类 方法 接口不能提供任何代码 抽象类的非抽象函数可以提供完整代码 数据字段 只包含public static final常量，常量必须在声明时初始化。 可以包含实例变量和静态变量以及实例和静态常量。 含义 接口通常用于描述一个类的外围能力，而不是核心特征。类与接口之间的是-able或者can do的关系，有instanceof关系（实现了接口的具体类对象也是接口类型的实例）。 抽象类定义了它的后代的核心特征。例如Person类包含了Student类的核心特征。子类与抽象类之间是is-a的关系，也有instanceof关系（子类对象也是父类实例）。 简洁性 接口中的常量都被假定为public static final，可以省略。不能调用任何方法修改这些常量的初始值。接口中的方法被假定为public abstract。 可以在抽象类中放置共享代码。可以使用方法来修改实例和静态变量的初始值，但不能修改实例和静态常量的初始值。必须用abstract显式声明方法为抽象方法。 添加功能 如果为接口添加一个新的方法，则必须查找所有实现该接口的类，并为他们逐一提供该方法的实现，即使新方法没有被调用。 如果为抽象类提供一个新方法，可以选择提供一个缺省的实现，那么所有已存在的代码不需要修改就可以继续工作，因为新方法没有被调用。 基本数据类型包装类的作用 为基本数据类型提供有用的方法和常量值 用于只能处理对象引用的地方（比如Java所有的集合类里只能放对象） 包装类对象的值不变（内部valule是final的），只能读取。 构造函数 以一个对应的基本数据类型为参数 以字符串为参数(除了Character) 如Double类的构造函数如下： public Double (double value); public Double (String value); 例如 Double doubleObject = new Double(5.0);","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:9","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"异常处理和文本I/O 异常：程序运行过程中发生的非正常时间，其发生会影响程序的正常执行 当程序产生异常是，产生异常对象交给程序处理，称为抛出一个异常 异常的原因：数组越界、违反语意、资源超出限制、访问空引用等…… 显式抛出异常： throw new Exception(\"异常描述信息\"); 使用try/catch语句环绕可能会抛出异常的代码段。 Java异常必须继承Throwable的直接或间接子嘞。用户通过继承自定义异常 Java的异常分为两大类：从Exception派生的是程序级错误，程序本身可以处理；从Error派生的是系统错误（如JVM内存不够），程序可不用处理也处理不了。 Exception的子类除了RuntimeException分支之外都是必检异常，要么用catch子句捕获并处理，要么在所在函数上加上异常声明 发生异常时： 运行时系统按与方法调用次序相反的次序搜索调用堆栈，寻找一个包含可处理异常的代码块的方法，这个代码块即异常处理器，即try/catch子句。 如果被抛出的异常与异常处理器可以处理的类型匹配，则捕获异常； 如果彻底搜索调用堆栈中所有方法都没有合适的异常处理器，则程序终止。 ","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:10","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"泛型 泛型（Generic）：指可以把类型参数化，这个能力使得我们可以定义带类型参数的泛型类、泛型接口、泛型方法，随后编译器会用唯一的具体类型替换它； 主要优点：是在编译时而不是运行时检测出错误。泛型类或方法允许用户指定可以和这些类或方法一起工作的对象类型。如果试图使用一个不相容的对象，编译器就会检测出这个错误。 实现原理：Java的泛型通过擦除法实现，和C++的模板生成多个实例类不同。编译时会用类型实参代替类型形参进行严格的语法检查，然后擦除类型参数、生成所有实例类型共享的唯一原始类型。这样使得泛型代码能兼容老的使用原始类型的遗留代码。 泛型类（Generic Class）是带形式化类型参数的类。形式化类型参数是一个逗号分隔的变量名列表，位于类声明中类名后面的尖括号\u003c\u003e中。下面的代码声明一个泛型类Wrapper，它接受一个形式化类型参数T： public class Wrapper\u003cT\u003e { } T是一个类型变量，它可以是Java中的任何引用类型，例如String，Integer，Double等。当把一个具体的类型实参传递给类型形参T时，就得到了一系列的参数化类型(Parameterized Types)，如Wrapper，Wrapper ，这些参数化类型是泛型类Wrapper的实例类型,参数化类型(Parameterized Types)是在JLS里面使用的术语，为了方便描述我们称为实例类型。 Wrapper\u003cString\u003e stringWrapper = new Wrapper\u003cString\u003e(); Wrapper\u003cCircle\u003e circleWrapper = new Wrapper\u003cCircle\u003e(); RTTI（ Run-Time Type Identification ）：运行时类型识别。 通过运行时类型信息，程序在运行时能够检查父类引用所指的对象的实际派生类型。 Class和Class对象 要理解RTTI在Java中的工作原理，就必须知道类型信息在运行时是如何表示的。 类型信息是通过Class类（类名为Class的类）的对象表示的，Java利用Class对象来执行RTTI。 每个类都有一个对应的Class对象，每当编写并编译了一个类，就会产生一个Class对象，这个对象当JVM加载这个类时就产生了。 获取Class对象： Class.forName方法，是Class类的静态方法: class Person{ } class Employee extends Person{ } class Manager extends Employee{ } public class ClassDemo { public static void main(String[] args){ try { Class clz = Class.forName(“ch13.Manager”); //参数是类完全限定名字符串 System.out.println(clz.getName()); //产生完全限定名ch13.Manager System.out.println(clz.getSimpleName()); //产生简单名Manager Class superClz = clz.getSuperclass(); //获得直接父类型信息 System.out.println(superClz.getName()); //产生完全限定名ch13.Employee System.out.println(superClz.getSimpleName()); //产生简单名Employee } catch (ClassNotFoundException e) { e.printStackTrace(); } } } 利用类字面常量：类名.class，得到类对应的Class对象 某个类名.class是Class类型的字面量，正如int类型的字面量有1，2，3，Class类型的字面量有Person.class, Employee.class, Manager.class，它们都是Class类型的实例 类字面常量不仅可以用于类，也可用于数组(int[].class)，接口，基本类型，如int.class 相比Class.forName方法，这种方法更安全，在编译时就会被检查，因此不需要放在Try/Catch块里 Class.forName会引起类的静态初始化块的执行，T.class不会引起类的静态初始化块的执行 public class ClassDemo { public static void main(String[] args){ Class clz = Manager.class; // Manager.class得到Manager的Class对象.赋给引用clz System.out.println(clz.getName()); //产生完全限定名ch13.Manager System.out.println(clz.getSimpleName()); //产生简单名Manager } } 通过对象:如果获得一个对象的引用o，通过o.getClass()方法获得这个对象的类型的Class对象 public class ClassDemo { public static void main(String[] args){ Object o = new Manager(); Class clz = o.getClass();//注意getClass返回的是运行时类型 System.out.println(clz.getName()); //产生完全限定名ch13.Manager System.out.println(clz.getSimpleName()); //产生简单名Manager } } 泛化的Class引用 //非泛化的Class引用（即不带类型参数的Class引用）可指向任何类型的Class对象，但这样不安全 Class clz ; //注意警告， Class is a raw type. References to generic type Class\u003cT\u003e should be parameterized clz= Manager.class; //OK clz = int.class; //OK //有时我们需要限定Class引用能指向的类型：加上\u003c类型参数\u003e。这样可以可以强制编译器进行额外的类型检查 Class\u003cPerson\u003e genericClz; //泛化Class引用，Class\u003cPerson\u003e只能指向Person的类型信息， \u003cPerson\u003e为类型参数 genericClz = Person.class; //OK //genericClz = Manager.class; //Error，不能指向非Person类型信息。注意对于类型参数，编译器检测时不看继承关系。 //能否声明一个可用指向Person及其子类的Class对象的引用？为了放松泛化的限制，用通配符?表示任何类型，并且与extends结合，创建一个范围 Class\u003c? extends Person\u003e clz2; //引用clz2可以指向Person及其子类的类型信息 clz2 = Person.class; clz2 = Employee.class; clz2 = Manager.class; //注意Class\u003c?\u003e 与Class效果一样，但本质不同，一个用了泛型，一个没有用泛型。 Class\u003c?\u003e 等价于Class\u003c? extends Object \u003e 反射（Reflection） 完成这样的功能：输入一个类的完全限定名字符串（如“java.lang.String”），创建相应的对象。 利用Class对象我们可以在运行时动态地创建对象，调用对象的方法。clz指向一个类的Class对象时，通过 clz可以得到这个类的所有构造函数对象，方法对象。 一个构造函数对象类型是： java.lang.reflect.Constructor，一个Constructor对象代表了类的一个构造函数 一个方法对象类型是：java.lang.reflect.Method，一个Method对象代表了类的一个方法 通过反射机制创建对象/调用方法： 首先得到参数类型为String的构造函数对象，然后调用它的newInstance方法调用构造函数，参数为“John”。等价于： Student s2 = new Student(“John”)； clz.getMethod(“setName”, String.class)：得到方法名为setName,参数为String的方法对象m，类型是Method。 然后通过m.invoke去调用该方法，第一个参数为对象，第二个参数是传递给被调方法的实参。这二条语句等价于s1.setName(“Marry)。 Class clz = Class.forName(\"ch13.Student\"); //获取所有的Constructor对象 Constructor[] ctors = clz.getConstructors(); //获取所有的Method Method[] methods = clz.getMethods(); //会显示所有方法，包括继承的 Method[] methods = clz.getDeclaredMethods(); //本类定义的方法 //实例化对象 //1：如有缺省构造函数，调用Class对象的newInstance方法 Stud","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:11","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"多线程和并行程序设计 线程的概念 一个进程的多个子线程可以并发运行 多线程可以使程序反应更快、交互性更强、执行效率更高。 特别是Server端的程序，都是需要启动多个线程来处理大量来自客户端的请求 一个典型的GUI程序分为 GUI线程：处理UI消息循环，如鼠标消息、键盘消息 Worker线程：后台的数据处理工作，比如打印文件，大数据量的运算 Runuable接口和线程类Thread 创建线程方法：线程的执行逻辑（后面叫线程任务）必须实现java.lang.Runnable接口的唯一run方法。此外，由于Thread实现了Runnable接口，也可以通过Thread派生线程类。 因此有两种方法可以实现同一个或多个线程的运行： 实现Runnable接口，需要实现唯一的接口方法run void run( ) 该方法定义了线程执行的功能 创建实现Runnable接口的类的对象——线程任务类，定义线程任务逻辑 利用Thread类的构造函数创建线程对象——代表线程类，定义线程的管理 通过线程任务类（TaskClass）创建任务对象（task） 以任务对象task为参数new Thread对象。Thread对象代表一个线程，线程的执行内容由任务对象task定义。 通过线程对象thread启动线程thread.start( )，任何线程只能启动一次，多次调用产生IllegalThreadStateException异常。 //Custom task class class TaskClass implements Runnable { ... //可以有自己的数据成员 public TaskClass(...) { ... } //Implement the run method in Runnable public void run() { //Tell system how to run custom thread ... } } //Client Class public class Client { ... public void someMethod(...) { ... // Create an instance of TaskClass Runnable task = new TaskClass(...); // Create a thread Thread thread = new Thread(task); // Start a thread thread.start(); // 启动后自动执行task.run } } 通过继承Thread类创建线程 定义Thread类的扩展类（CustomThread） 通过扩展类（CustomThread）创建线程对象（thread） 通过线程对象thread启动线程thread.start() // Custom thread class class CustomThread extends Thread { //数据成员 public CustomThread(...) { ... } public void run() { // Tell system how to perform this task ... } ... } //Client class public class Client { ... public void someMethod() { ... // Create a thread Thread thread1 = new CustomThread(); // Start thread thread1.start( ); //激活thread1对象的run // Create a thread Thread thread2 = new CustomThread( ); // Start thread thread2.start(); //激活thread2对象的run } ... } 线程和线程任务混在一起，不建议使用 Java不支持多继承，CustomThread继承了Thread类不能再继承其他类 线程的状态转换 线程优先级范围从1－10，数字越高越能被优先执行。但优先级高并不代表能独自占用执行时间片，可能是优先级高得到越多的执行时间片，反之，优先级低的分到的执行时间少但不会分配不到执行时间 每个线程创建时赋予默认的优先级Thread.NORM_PRIORITY. 通过setPriority(int priority)为线程指定优先级. 用getPriority()方法获取线程的优先级. JAVA定义的优先级：1～10 Thread类有int 类型的常量： Thread.MIN_PRIORITY（1） Thread.MAX_PRIORITY（10） Thread.NORM_PRIORITY（5） 多个线程只能是“宏观上并行，微观上串行” 在有限个CPU的系统中确定多个线程的执行顺序称为线程的调度 Java的线程调度是抢占式的，这表示调度机制会周期性地中断线程，将上下文切换到另外一个线程；从而为每个线程都提供时间片 自私的线程 run() { while (true) { } } 应适当地在run()里sleep或yield一下，让其他线程有更多机会被运行。 使用 yield() 方法为其他线程让出CPU时间： public void run() { for (int i = 1; i \u003c times; i++) { System.out.print(charToPrint); Thread.yield(); //挂起进入ready，给其它进程调度机会 } } sleep(long mills)方法将线程设置为休眠状态，确保其他线程执行: public void run() { try {//循环中使用sleep方法，循环放在try-catch块中 for (int i = 1; i \u003c times; i++) { System.out.print(charToPrint); if (i \u003e= 50) Thread.sleep(1); } } // 必检异常：其它线程调当前线程（正在休眠）interupt方法会抛出该异常 catch (InterruptedException ex { } } //处于阻塞状态（如在睡眠，在wait，在执行阻塞式IO）的线程，如果被其他线程打断（即处于阻塞的线程的interupt方法被其它线程调用），会抛出InterruptedException join方法的作用：在A线程中调用了B线程（对象）的join()方法时，表示A线程放弃控制权（被阻塞了），只有当B线程执行完毕时，A线程才被唤醒继续执行。 public class JoinDemo { public static void main(String[] args) throws InterruptedException{ Thread printA = new Thread(new PrintChar('a',100)); Thread printB = new Thread(new PrintChar('b',100)); printA.start(); //在主线程里首先启动printA线程 printA.join(); //主线程被阻塞，等待printA执行完 printB.start(); //主线程被唤醒，启动printB线程 } } class PrintChar implements Runnable { private char charToPrint; // The character to print private int times; // The times to repeat public PrintChar(char c, int t){ charToPrint = c; times = t; } public void run(){ //实现Runnable中声明的run方法 for (int i=1; i \u003c times; i++) System.out.print(charToPrint); } } 线程池 由于要为每一个线程任务创建一个线程（Thread对象），对于有大量线程任务的场景就不够高效 （当线程任务执行完毕，即run方法结束后，Thread对象就消亡，然后又为新的线程任务去new新的线程对象…, 当有大量的线程任务时，就不断的new Thread对象，Thread对象消亡，再new Thread对象…） 线程池适合大量线程任务的并发执行。线程池通过有效管理线程、“复用” 线程来提高性能. 从JDK 1.5 开始使用Executor接口（执行器）来执行线程池中的任务，Executor的子接口ExecutorService管理和控制任务![截屏2021-04-21 上午8.26.24](JAVA学习笔记/截屏2021-04-21 上午8.26.24.png) 使用Executors的类方法创建一个线程池，Executors由Object派生 +newFixedThreadPool(numberOfThreads:int)：创建一个可以运行指定数目线程的线程池，一个线程在当前任务已经完成的情况下可以重用，来执行另外一个任务 +newCachedThreadPool()：创建一个线程池，它会在必要的时候创建新的线程，但是如果之前已经创建好的线程可用，则先重用之前创建好的的线程（尽量复用，不够再创建新线程） Executors还支持其它类型的线程池的","date":"2021-05-08","objectID":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:12","tags":["Java"],"title":"Java学习笔记","uri":"/java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["技术笔记"],"content":"iOS中的网络编程和多线程编程 ​ 博主的寒假学习任务的第一个任务即学习多线程编程。在读《Objective-C高级编程》（里面的GCD版本有点老）的时候我了解了block和GCD多线程编程的使用方法，在网易彩票demo自定义tabbar切换场景和翻牌游戏的翻牌动画中进行了使用。私以为网络编程和多线程编程是学习iOS开发中的重点，下面来归纳整理一些相关知识。 ​ 移动互联网时代几乎所有的应用程序都要使用网络请求，而为了编写高效的网络请求模块，开发者必须能灵活运用多线程的各种操作。 ","date":"2021-02-07","objectID":"/ios%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/:0:0","tags":["iOS"],"title":"iOS中的网络编程与多线程编程","uri":"/ios%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"categories":["技术笔记"],"content":"多线程编程 ​ 先来简单复习一下操作系统里线程的概念： 线程是操作系统任务调度的基本单元，合理使用多线程才能充分利用多核CPU，合理设置优先级让重要的任务更快完成（比如主线程）。 线程共享一个进程内的资源，共享虚拟内存/描述符等，多个线程访问贡献资源可能会存在竞争。 线程有独立的调用栈/本地变量/寄存器上下文，线程的创建/销毁/切换也是有一定开销的，只不过这个开销要比进程小。 多线程指从软件或硬件上实现多个线程并发执行的技术，进而提升整体的处理性能。 ​ iOS中实现多线程编程主要有三个方法，也有四个的说法。主要的三个指的是：NSThread、GCD和NSOperation。四个的说法是因为OC兼容了C语言，故而C语言中的POSIX接口也可以用来使用多线程，也就是引用C的头文件pthread.h（博主在学校的操作系统实验里用了这个写多线程，好麻烦…）。 ​ 多线程编程的难点主要有：多线程下操作的顺序不可预测、编译器优化会重排代码、CPU会乱序执行指令，因此不要对执行顺序妄作假设。 ​ NSThread ​ NSThread是封装程度最小、最轻量级的多线程编程接口，它使用更灵活，但要手动管理线程的生命周期、线程同步和线程加锁等，开销较大。其使用比较简单，可以动态创建初始化NSTread对象。静态快速创建并开启一个新线程可以使用+detachNewThreadSelector:toTarget:withObject与+detachNewThreadWithBlock:。 ​ NSObject基类对象提供了隐式快速创建NSThread线程的performSelector系列扩展工具类方法（如在指定线程上执行方法的performSelector:onThread:withObject:waitUntilDone:），和一些静态工具接口来控制当前线程以及获取当前线程的一些信息。 ​ 部分常用的方法包括：开启线程（start）、是否开启了多线程（+isMultiThreaded）、获取当前线程（+currentThread）、获取主线程（+mainThread）、睡眠当前进程、设置优先级（.threadPriority）等。 GCD⭐⭐⭐ ​ GCD，即Grand Central Dispatch，又叫大中央调度（某些书会译作大中枢派发），它对线程的操作进行了封装，加入了很多新特性，内部进行了效率优化，提供了简洁的C语言接口，使用更加简单高效，也是苹果公司提供的方式。 ​ GCD的好处包括有：GCD可用于多核的并行计算；GCD会自动利用更多的CPU内核；GCD会自动管理线程的生命周期（创建线程、调度任务、销毁线程） ​ GCD的队列主要有三种：全局并发队列、主队列和用户创建的队列，队列按并发性可分为并发队列和串行队列。主队列的本质是串行队列。注意队列和线程并不是一一对应，主线程上执行的队列可能不止一个。 ​ 队列中的任务又有执行方式的区别，分为同步执行（dispatch_async）和异步执行（dispatch_sync）。同步指阻塞当前线程，等添加的耗时任务完成后再返回，而异步则是将任务添加到队列后返回，后面的代码不需要等待添加的任务完成即可继续执行。 ​ 注意理解不同队列和不同执行方式的组合。这个比较难以理解，写起来篇幅挺长的^^，可以参考一下别的好博客。 ​ 一些常用函数： ​ dispatch_once_t：控制代码指定代码只执行一次，常用来实现单例模式。 ​ dispatch_after：提交的任务从提交开始后的指定时间执行。 ​ dispatch_group_t：组调度，实现等待一组操作都完成后执行后续操作，应用场景有比如大图片下载，分块下载再拼接。 ​ dispatch_barrier_async：设置栅栏，栅栏后的任务一定在栅栏前的任务们完成之后执行。 ​ 队列优先级建议使用默认的default优先级。 NSOperation ​ NSOperation是基于GCD的一个基类，它也不需要管理线程的声明周期和同步，但比GCD可控性更强，可以指定任务依赖、设置并发数、取消任务和KVO监听任务状态。 ​ NSOperation是一个抽象基类，使用时使用的是其两个实体子类NSBlockOperation和NSInvocationOperation（前者指定操作的Block，后者指定操作的方法）。异步执行可以加入NSOperationQueue，具体使用可以看API的说明。 线程安全 ​ 定义：当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替运行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获取正确的结果，那么这个对象是线程安全的。 ​ iOS中线程不安全的对象，如NSMutableArray，在其说明文档中没有被注明线程安全。 ​ 只能在某个线程使用的对象：UIKit/CoreAnimation中几乎所有的对象都只能在主线程中使用，但也有例外：UIImage和UIFont。 ​ 在Xcode可以开启Thread Sanitizer来帮助检查哪些代码违反了线程安全的原则，Main Thread Checker来帮助查看是否有不安全的API使用。 ​ 同步机制 ​ iOS里的同步机制主要有： ​ @synchronized：OC语言提供的内置的同步机制，使用的方法很简单，@synchronized(要同步的对象指针){} ​ NSLock/NSRecursiveLock：创建一个NSLock的实例，调用-lock和-unlock来上锁和开锁。注意开关锁之间是可以嵌套锁的，而NSRecursiveLock可以保证嵌套调用时不会死锁。 ​ GCD的同步机制：同步执行、创建串行队列、组队列、阻塞任务（barrier）、以及信号量机制（dispatch_semapore）。 ​ NSOperation同步机制：设置依赖性、最大并发数。 ​ 多线程练习小游戏：deadlockempire.github.io ","date":"2021-02-07","objectID":"/ios%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/:1:0","tags":["iOS"],"title":"iOS中的网络编程与多线程编程","uri":"/ios%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"categories":["技术笔记"],"content":"网络编程 ​ 在计算机网络里我们深入了解了HTTP这一超文本传输协议，iOS开发中发送HTTP请求有以下几种方案：NSURLConnection、NSURLSession（iOS7之后逐渐取代NSURLConnection）、CFNetwork（用于TLS、TCP和UDP连接，需要iOS12+）和其他第三方网络请求框架（如OC里的AFNetworking，TTNetWorkManager）。 HTTP与HTTPS ​ HTTP：HTTP现在最新的是2.0版本，比起1.1版本它支持多路复用（二进制分帧）、服务端主动推送（现在推送主要有长连接和客户端轮询）、头部压缩、随时复位、优先权等。 ​ HTTPS：HTTP协议是以明文方式发送内容，为了解决这个安全性的缺陷，HTTPS在HTTP的基础上加入了SSL加密传输协议，增加了TLS层（传输层安全），依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密，使用端口号443。 ​ Charles抓包工具，截取HTTP和HTTPS网络数据，可以改数据。 ​ 数据格式 ​ 主要有JSON（最常用）和PB，苹果官方提供了JSON的序列化和反序列化的API。 ​ JSON我们都熟悉，是JS的对象表示法，独立于语言和环境的轻量级文本数据交换格式，在网络传输中一般是使用GZip压缩算法。 ​ PB则是一种比JSON体积更小、解析速度更快的结构化数据存储格式，编译期间就可保证正确性，采用标识-长度-字段值表示单个数据（T-L-V数据存储方式），缺点是服务端新增字段就需要重新生成打包文件。 NSURLSession ​ 通过task来管理，主要有四种task： DataTask：数据请求 DownloadTask：文件下载、下载进度、断点续传等 UploadTask：文件上传 StreamTask：TCP连接（iOS9+） Network.framework ​ Network.framework具有智能建立连接、优化数据传输、进行安全加密、兼容移动网络等特性，使用参考苹果的API说明文档。 AFNetWorking ​ 很好用的第三方框架，在GitHub上可以看到其说明文档。 TTNetworkManager ​ 头条自研的API，暂时没有使用过，主要有如下特性： 具有AFNetwork和ChromeNet内核，可以动态切换 有细致的timing信息，可以用来排查网络瓶颈。 错误信息明确 C++跨平台源码公开 支持HTTPDNS（传统的DNS需要在运营商进行IP地址转换，HTTP可以在服务器存储的列表中拿到IP地址） 支持HTTP2.0和QUIC 支持选路和流控等新功能 ","date":"2021-02-07","objectID":"/ios%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/:2:0","tags":["iOS"],"title":"iOS中的网络编程与多线程编程","uri":"/ios%E4%B8%AD%E7%9A%84%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"},{"categories":["技术笔记"],"content":"iOS中的内存管理 ​ 小心内存管理，小心内存管理，小心内存管理！需要不断积累和深入思考才能写出高质量的安全代码。内存管理直接决定着程序的安全性和稳定性，内存管理核心的话题主要包括：循环引用、内存泄露、内存管理规则和垃圾回收机制等。 ","date":"2021-02-06","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:0:0","tags":["iOS"],"title":"iOS中的内存管理","uri":"/ios%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["技术笔记"],"content":"内存管理 内存泄漏和安全释放 ​ 内存泄露指的是动态分配内存的对象在使用完后没有被系统回收内存，导致该对象始终占用内存，又无法通过代码访问，属于内存管理出错，如果出现大量内存泄露，那么会导致系统内存不足的问题。 ​ 安全释放指释放掉不再使用的对象的同时不会造成内存泄露或指针悬挂问题的操作。为了保证安全释放，在对象dealloc后要将其指针置为nil。另外要严格遵守内存管理原则，保证对象的引用计数正确，同时要注意避免引用循环的出现。 ​ 要求我们养成良好的编程习惯，可以借助Xcode的Instruments调试工具检测有内存泄露隐患的代码。 僵尸对象、野指针、空指针 ​ 僵尸对象：引用计数为零的OC对象被释放后就变成僵尸对象，内存已经被系统回收，虽然对象还可能存在，数据依然在内存中，但是已经是不稳定对象了，不可以再访问和使用。僵尸对象所占内存是正常的，不会造成内存泄露。 ​ 野指针：又称为\"悬挂指针\"，野指针出现的原因是指针没有赋值，或者原指向的对象被释放了。野指针指向随机的一块垃圾内存，向它们发送消息会报EXC_BAD_ACCESS错误导致程序崩溃。 ​ 空指针：不同于野指针，它是没有指向任何内容的指针，但是是有效指针，其值为nil、NULL、0、Nil等，向其发消息不会报错。 GC与RC ​ GC即垃圾回收机制Garbage Collection，它是宏观地对整体进行内存管理，将所有对象看作一个集合，然后在GC循环中定时检测活动对象和非活动对象，及时将用不到的非活动对象释放掉以避免内存泄露。 ​ RC即引用计数Reference Counting，是局部性的，OC中每次Runloop都会检查对象引用计数，引用计数为0后会被系统马上释放掉。而自动释放池像一个局部的垃圾回收，将部分垃圾对象集中释放，相对于单个释放会有一定的延迟。 ​ OC支持垃圾回收机制，但是有平台局限性，仅限于Mac桌面开发中，而在移动设备开发中不支持垃圾回收机制。移动设备开发中的内存管理采用MRC手动引用技术或ARC自动引用计数，通过计数引用的方式来管理内存的分配和释放。 alloc、dealloc、retain、release ​ alloc：创建对象，刚创建的对象默认引用计数为1，相当于在alloc创建过程中调用一次retain使引用计数+1。 ​ dealloc：销毁对象，在对象引用计数为0的时候系统自动调用。 ​ retain：保留对象，使对象引用计数+1。 ​ release：释放对象，使对象的引用计数-1。 ​ 需要注意retain、release方法只能在MRC下可以使用。 ","date":"2021-02-06","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:1:0","tags":["iOS"],"title":"iOS中的内存管理","uri":"/ios%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["技术笔记"],"content":"内存管理机制 block中避免引用循环 ​ 在一个对象中强引用了一个block，在该block中又强引用了该对象，就会出现该对象和该block的循环引用。解决这个引用循环一般有两种方法：一种是将一方强制置为nil，破坏循环；另一种是使用_ _ weak或 _ _block修饰对象。 CAAnimation的代理是强引用 ​ CAAnimation的代理是强引用，这是一个特例，因为CAAnimation动画是异步的，不是强引用可能会使其随时被释放掉。使用动画时需要采取措施避免循环引用，例如及时合适时机（在视图移除之前）移除动画。 手动释放的法则 ​ 在MRC中手动管理内存，基本原则是：谁创建，谁释放，谁引用，谁管理。即使用new、alloc、copy关键字和retain了的对象等需要手动释放掉，但设置了autorelease的对象不需要手动释放。注意数组的add操作时添加成员对象的强引用。 ​ MRC下静态方法创建的对象会自动进入自动释放池而不需要手动释放。例如创建一个NSString对象时注意，字面量（或被弃用的WithString）方法创建创建的是不可变字符串，位于常量内存区，可以认为已经被autorelease了，而stringWithFormat和initWithFormat方法创建的是在堆上，MRC下要手动管理内存。 autoreleasepool ​ autoreleasepool，即自动释放池，其实没有自身的结构，是基于多个AutoreleasePoolPage（一个C++类）以双向链表组合起来的结构，所以它的简单操作都是封装了AutoreleasePoolPage的操作结构。自动释放池位于栈上，符合先进后出原则。对比release操作的立即-1，autorelease操作是在对象的使用真正使用后才做引用计数-1，它的底层代码就是将对象添加到自动释放池。注意对一个对象连续两次调用autorelease后，由于自动释放池将其释放了不止一次，第二次释放时它成为了野指针，会导致崩溃。 ​ 向自动释放池发送drain和release(release在支持GC的系统中不会引起回收操作)会清理自动释放池，即向池内所有对象发送release消息，故一般使用系统兼容性更强的drain消息来清理自动释放池。对于每一个新的RunLoop，系统都会隐式地创建一个自动释放池，RunLoop结束后自动释放池便会对对象进行释放操作。 其他注意事项 ​ 在NotificationCenter中，添加对象到通知中心进行通知注册，通知中心只保存该对象的地址，但是没有强引用，如果这个对象释放了却没有在通知中心remove，那么通知发生时向保存的这个对象的地址发消息会导致崩溃。 ​ NSArray的Copy是浅拷贝，MutableCopy是深拷贝；NSMutable的Copy和MutableCopy都是深拷贝。 ","date":"2021-02-06","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/:2:0","tags":["iOS"],"title":"iOS中的内存管理","uri":"/ios%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"categories":["技术笔记"],"content":"数据持久化是应用开发中的重要部分，博主在编写一个网易彩票app的demo时(项目可以在我的github上找到，WYLottery)使用到了数据持久化来保存用户的设置，设置界面搭建也是借助plist文件来保存层次和属性，今天来整理一下iOS中数据持久化的方案与原理。iOS中的数据持久化的方案主要包括：NSUserDefault简单数据快速读写、Property list属性列表文件存储、Archive归档、SQLite本地数据库和CoreData。","date":"2021-02-05","objectID":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/","tags":["iOS"],"title":"iOS中的数据持久化","uri":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["技术笔记"],"content":"iOS中的数据持久化 ​ 数据持久化是应用开发中的重要部分，博主在编写一个网易彩票app的demo时(项目可以在我的github上找到，WYLottery)使用到了数据持久化来保存用户的设置，设置界面搭建也是借助plist文件来保存层次和属性，今天来整理一下iOS中数据持久化的方案与原理。iOS中的数据持久化的方案主要包括：NSUserDefault简单数据快速读写、Property list属性列表文件存储、Archive归档、SQLite本地数据库和CoreData。 ","date":"2021-02-05","objectID":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/:0:0","tags":["iOS"],"title":"iOS中的数据持久化","uri":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["技术笔记"],"content":"数据持久化方案 NSUserDefault与Archive归档 ​ NSUserDefault是iOS系统提供的一个单例类，采用简单的键值对存储方式，将用户的偏好设置保存到应用包的plist中，同时也能从中读取。添加新数据时需要自定义key和对应的基本类型的数据，获取时通过自定义key来获取，若不存在对应key则返回默认值（0或-1）。虽然存储的时基本类型数据，但我们也可以将集合数据转化成JSON字符串，以NSString的类型保存，通过这样来存储集合数据，便于加密解密。 ​ 通过+standardUserDefaults来获取NSUserDefault单例。通过-setObject:ForKey:和-object:ForKey:来存取数据。 ​ 序列化和归档（Archive），指的是将程序语言的对象转化成二进制流从而存储到文件中，因为对象不可以直接存储，反序列化和反归档（Unarchive）则反之。NSKeyedUnarchiver类继承自NSCoder，可以将满足NSCoding协议的对象进行归档，和NSData类型进行相互转换。若要实现多个对象同时归档和反归档，可以自定义并初始化一个NSKeyedArchiver对象，将数据封装在NSMutableData中进行统一的归档和反归档。 ​ 如果要想通过NSUserDefault保存自定义对象，需要做以下额外操作： 保证自定义类遵循NSCoding协议并实现协议进行编码/反编码； 使用NSKeyedUnarchiver类将自定义对象转换成NSData对象。 ​ 这样自定义对象转化成了NSData，就可以用NSUserDefault存储了，只不过取数据的时候需要NSKeyedUnarchiver来解档还原。归档成NSData对象的对应的归档解档方法（也可以调用别的方法归档成.achiver文件）分别为+archivedDataWithRootObject:与+unarchiveObjectWithData:。 Property list文件存储 ​ Property List文件，扩展名为.plist，所以常被称为plist文件。主要用来存储序列化后的对象，文件是xml格式的，常用于存储用户的设置信息，也可以用于存储捆绑的信息等。 ​ 在使用plist文件存储前先要明确数据的不同存储位置： 存储到应用沙盒（可写可读，详见后文），沙盒是应用的隔离区域，plist存储在沙盒的Documents文件目录下，写入时要指明plist文件的文件名，如“/demo.plist” 存储到应用工程本身（只可读）。如果是将数据存在工程里，那么plist数据文件是手工创建的，而非代码添加，代码只对手工创建的plist文件进行读取且不可更新，更新只能通过手动修改plist文件更新数据。 读取工程plist文件并写入沙盒以及读取沙盒plist文件 SQLite本地数据库 ​ iOS中的SQLite是一个使用ANSI-C开发的自包含的关系型数据库，它可以用于存储大规模的数据。SQLite的操作管理很简单，有小巧、快速、可靠的特点。另外SQLite使用互斥来保证多线程环境下数据操作的安全性。 ​ SQLite源代码是一个叫sqlite3.c的文件，在使用时只要加入这个库文件同时在代码中引入sqlite.h头文件即可 CoreData ​ CoreData是苹果公司提供的一种应用数据管理框架，可以用图形界面的方式快速地定义App的数据类型，同时在代码中很容易获取这些数据类型。CoreData提供了基础结构用于处理常用的功能，如保护、恢复、撤销和重做，允许在App中继续创建新的任务。在使用CoreData的时候，不需要安装额外的数据库系统，因为CoreData使用内置的SQLite数据库。 ​ CoreData的最本质特点是提供了一种将对象模型和关系数据进行映射的功能，称为对象-关系映射（ORM），可以将模型对象和关系数据相互转换在SQLite数据库中存取。 ","date":"2021-02-05","objectID":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/:1:0","tags":["iOS"],"title":"iOS中的数据持久化","uri":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["技术笔记"],"content":"沙盒机制 ​ 沙盒是应用程序中一块相对封闭的独立空间，需要通过特殊限制通道才能访问沙盒外系统的资源。沙盒是为了系统安全而设置的访问屏障，限制应用程序访问系统文件、系统偏好、网络资源和硬件设备等，沙盒内的应用不会对系统安全有威胁。应用程序只能访问自己的沙盒，应用程序之间禁止数据的共享和访问。 沙盒的子目录 ​ Documents目录 ​ 主要用于存储非常大的文件或需要非常频繁更新的数据，目录中的文件可以进行iTunes或iCloud的备份。 ​ Library目录 ​ Library目录下后Preferences和Cache目录，如其名，Preferences目录主要用于存储应用程序的偏好设置数据，可以进行iTunes或iCloud的备份。而Caches目录不可以进行iTunes或iCloud的备份，主要用于存放存储体积大、不需要备份的数据缓存文件。 ​ tmp目录 ​ tmp目录是应用程序的临时目录，里面的文件不可以进行iTunes或iCloud的备份，而且这里面的文件可能会随时被系统清除。 ​ 虽然不能直接访问其他应用程序中的数据，但是可以借助iOS提供的特定的API访问一些特殊应用，如联系人应用等。 ​ ","date":"2021-02-05","objectID":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/:2:0","tags":["iOS"],"title":"iOS中的数据持久化","uri":"/ios%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/"},{"categories":["技术笔记"],"content":"iOS中的图层与动画 ​ 前段时间博主开发了一个旦旦翻牌game的小demo（寒假实验室的学习任务，可以在我的github上找到CardGame仓库），自己写了个翻牌动画。开发之路刚刚起步，需要开发知识和实战经验结合，来小总结一下iOS开发中关于图层和动画的一些基本知识~ ​ CoreAnimation是iOS和OS X平台上负责图像渲染与动画的基础框架，也是一组非常强大的动画处理API。使用CoreAnimation开发动画的本质就是将CALayer中的内容转化为位图供硬件操作。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:0:0","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"图层 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:1:0","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"UIView和CALayer ​ UIView类是所有视图的基类，CALayer是图层类，他们处于同层的平行关系，每一个UIView都有一个CALayer实例的图层属性。CALayer是对底层图形API层层封装得到的类，用于展示一些可见的图形元素，保留了一些基本的图形化操作。CALayer用于管理图形元素、制作动画，它保留了一些如尺寸、位置的几何属性。UIView简单来说是可以在里面渲染可见内容的矩形框，里面的内容可以与用户交互，对交互事件进行处理。 ​ CALayer可以通过UIView很方便地展示操作UI元素，单独使用灵活度更高，自身具有可设置的属性如背景色、边框和阴影等。 ​ UIView继承自UIResponder，UIResponder继承自NSObject；而CALayer直接继承自NSObject。因此两者主要区别为： CALayer无法像UIView一样响应用户事件 在分工上UIView类侧重于对现实内容的管理和整体布局，而CALayer侧重于显示内容的绘制、显示和动画 UIView属于UIKit.framework框架，CALayer属于QuartzCore.framework框架 ​ iOS中提供UIView和CALayer这两个平行层级结构，实现视图的绘制、显示和布局解耦，避免了很多重复的代码。这样做的带来的好处就例如：UIKit框架不跨平台，在iOS和Mac OS上，两者事件和用户交互的实现有显著不同，但是视图绘制的QuartzCore和Core Graphics两个框架是跨平台的，两个平行层级结构方便两个平台的代码可以共享，使开发更便捷。 ​ Layer层对象是用来展示可见内容、渲染视图内容的对象，常用的有：CATextLayer（文字布局渲染）、CAShapeLayer（绘制矢量图形）、CAGradientLayer（主要用于平滑渐变）、CATransformLayer（展示3D图形变换）、CAScrollLayer（实现滚动视图）、AVPlayerLayer（播放视频）、CAEmitterLayer（粒子特效）。这些都是继承自CALayer。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:1:1","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"UIView及其子类的圆角等效果渲染 1.离屏渲染（直接设置layer圆角属性）：提前另开缓冲区进行的渲染，比较耗费性能； 2.当前屏幕渲染（自定义圆角绘制方法）：GPU直接在当前显示的屏幕缓冲区渲染，不用离开切换缓冲区，性能较高。 tips：为了防止离屏渲染的损耗，可以将处理图片的权利交于CPU，虽然图形处理性能不如GPU，但是圆角处理难度不大，代价远小于上下文切换，常用方法有：使用CALayer的shouldRasterize设置光栅化、通过CoreGraphics绘制圆角图片（用UIBezierPath剪切图片） ​ （小技巧：可以制作中间镂空的图片，颜色同背景的图片遮在图像上实现圆角效果，避免圆角渲染的性能问题） ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:1:2","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"点与像素 ​ 点是iOS中标准的坐标体系与虚拟像素（逻辑像素），一个点对应一个像素，但在Retina屏幕上一个点对应2*2个像素，这个坐标测算体系使在Retina设备和普通设备上有一致的视觉效果。 ​ 像素是图片分辨率的尺寸单位，即物理像素，和图片有相对关系。UIImage用点来度量大小，一些底层的CGImage类型的图片会使用像素。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:1:3","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"drawRect方法 ​ drawRect:方法被定义在UIView的UIViewRendering类别中，其中的代码利用Core Graphics在指定的rect中绘制图形，然后缓存起来等待被更新。它会在视图出现时被自动调用，具体是loadView和viewDidLoad两个方法之后，因此没有自定义绘图任务时，不要在子类中写空的drawRect:以免造成资源浪费。可以调用setNeedsDisplay将绘制好的图形更新到视图上（更新的原理是在receiver上设置需要重绘标记，在下个绘制周期自动重绘，一般的刷新频率为60Hz）。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:1:4","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"anchorPoint与position ​ anchorPoint相对于当前图层。 ​ 图层的position相当于视图中的center，是相对于父图层的位置。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:1:5","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"动画 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:0","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"隐式动画与显式动画 ​ 隐式动画：UIKit动画的基础，是iOS中创建动态UI界面的最直接的一种方式，通过直接设定UI元素的一些可见属性的目标值（如frame、bounds、center、transform、alpha等），生成属性变化的过渡动画，默认从一个初始状态线性变化到目标状态，例如基于block块的UIView的+animateWithDuration:animations:方法。 ​ 显示动画：需要显式地定义动画的完整流程，略微复杂的同时会更加灵活，可以实现更加复杂的动画效果。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:1","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"隐式动画原理 ​ 更改视图的非根图层的可动画属性时，CoreAnimation自动决定如何并且如何去做动画。动画的执行时间取决于当前事务（CATransaction），而动画类型取决于图层行为。CATransaction类是用于包含一系列属性动画的机制，可以用+begin与+commit来入栈和出栈。 ​ CALayer的属性被修改时，会调用actionForKey:方法，原理为： 图层检测是否有代理且代理是否实现了CALayerDelegate协议指定的-actionForKey:forKey方法，若有则直接调用并返回结果。 如果无这样的代理，则图层会接着检查包含属性名称对应行为映射的action字典。 如果action字典不包括对应的属性，则图层会在其style字典里搜索属性名。 如果style中无对应的行为，则图层会调用定义每个属性标准行为的-defaultActionForKey:方法。 ​ 每个UIView是其根图层的代理并且实现了-actionForKey:forKey方法，默认不执行任何动画即返回nil。还可以通过CATransaction的+setDisableActions来开关属性的隐式动画。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:2","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"CGAffineTransform与CATransform3D ​ CGAffineTransform：定义在CoreGraphics框架中，主要用于在二维平面对视图进行旋转、缩放和平移，事实上是一个可以和空间向量（如CGPoint）做乘法的3 x 2的矩阵。它被称为“仿射变换”——不论使用什么值的变换矩阵，图层中平行的两条线变换后依然平行。UIView中的transform属性和CALayer中的affineTransform属性都是CGAffineTransform类型。 ​ CATransform3D是CoreAnimation结构体，也是一个矩阵，主要用来实现更复杂的关于CALayer的3D操作。其相关动画函数多了z轴参数，CATransform3D中的m34元素用来控制3D变换的透视效果。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:3","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"CATransition ​ CATransition是CoreAnimation框架提供的转场动画类。 ​ 其type属性指定了转场动画的类型，主要有4个效果可选：fade、moveIn、push、reveal ​ 还有iOS的私有API，使用后在审核有被拒绝的风险：cube、oglFlip、suckEffect、rippleEffect、pageCurl、pageUnCurl、cameraIrisHollowOpen、cameraIrisHollowClose ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:4","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"UIVIew过渡动画 使用CATransition 使用UIView的过渡动画API，+transformWithView与+transformFromView:ToView 自定义过渡动画，基础原则为对原始图层外观截图，添加一段动画平滑过渡到图层改变后截图的效果。调用CALayer中的renderInContext:方法可以将图层内容绘制成图片然后在视图在显示出来。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:5","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"CAKeyframeAnimation ​ CAKeyframeAnimation，即关键帧动画，作用于单一的属性，是CAPropertyAnimation的一个子类，可以根据开发者提供的一连串随意的值来做动画，这些值即关键帧，每帧之间的绘制将由系统自动完成。 ​ 使用时需要注意，关键帧动画不能将当前值作为第一帧，动画执行后会自动跳转到第一帧的值，动画结束后会突然恢复到最后一帧的值。还可以使用path属性来指定关键帧，且做动画的属性不一定是可动画属性，可以对子属性和虚拟属性做动画，例如指定keyPath为transform.rotation来做旋转动画。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:6","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"UIViewController之间的转场动画 ​ 使用常用的跳转方式：push、pop、present与dismiss等，系统会提供默认的动画效果。 ​ 自定义转场动画时，需要注意的概念： presentingView指源视图控制器，presentedView指跳转目标控制器； UIViewControllerTransitionDelegate协议用于为跳转动画实现了UIViewControllerAnimatedTransitioning协议的对象，而UIViewControllerAnimatedTransitioning协议用于开展动画的展示时间和展示逻辑 UIViewControllerInteractiveTransitioning协议即交互式转场动画代理，主要用于交互式动画 UIViewControllerContextTransitioning协议即转场动画上下文协议，为动画提供必备的信息 ​ 实现自定义动画需要代表页面跳转关系的两个控制器对象和动画执行逻辑，实现的步骤为： 为源控制器和目标控制器分别设置一个遵守UIViewControllerAnimatedTransitioning协议的代理对象（可以设置为同一个对象）； 调用对应的跳转方法，此时系统会自动请求动画代理提供动画逻辑对象。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:7","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["技术笔记"],"content":"保持视图界面为动画结束时的状态 ​ 实际开发中有时会发现动画结束时，视图状态会快速返回到初始状态，因为动画过程中所看到的是呈现图层的效果，而图层属性真正的值并非是呈现的效果值，解决方法为： 设置动画对象的removeOnCompletion属性为NO。 设置动画对象的fillMode为kCAFillModeForwards，即填充动画状态。 为动画对象添加非空的键，以便不需要动画的时候将它从图层上移除。 ","date":"2021-02-04","objectID":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/:2:8","tags":["iOS"],"title":"iOS中的图层与动画","uri":"/ios%E4%B8%AD%E7%9A%84%E5%9B%BE%E5%B1%82%E4%B8%8E%E5%8A%A8%E7%94%BB/"},{"categories":["学习笔记"],"content":"计算机操作系统的考试复习笔记 第一章 绪论 1.1 操作系统与计算机体系结构的关系...","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"计算机操作系统 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第一章 绪论 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.1 操作系统与计算机体系结构的关系 操作系统与各层的关系 (1) OS对各层的管理和控制 ① 与硬件的关系：控制CPU的工作；访问存储器、设备驱动、中断处理； ② 与用户及其他软件的关系：控制、管理；提供方便的用户界面 ；计算机系统的组成；提供优质的服务；操作系统是其他系统软件和应用程序运行的基础，它为上层软件和用户提供运行环境，即提供方便简单的用户接口。 (2) 各层对OS的制约和影响 ① 下层硬件环境的制约： 提供OS运行环境基础； 影响并限制OS的功能实现（例如单CPU是顺序过程计算模型，与现代操作系统的并行计算模型存在矛盾）； ② 用户和上层软件的要求： 满足不同用户需求、提供良好的用户界面； 提高服务的质量、方便用户的使用越来越重要 存储程序式计算机的结构和特点 (1) 基本部件：CPU、存储器、I/O设备 (2) 特点：集中顺序过程控制：过程性、集中控制、顺序性 计算机系统结构与操作系统的关系 (1) 结构特征 操作系统是运行在计算机上的第一层系统软件。 早期单用户操作系统：顺序计算模型，容易实现，但昂贵的计算机部件没有得到充分利用 为了提高利用率，引入操作系统并行计算模型，与硬件的顺序计算模型是一对矛盾。 (2) OS采用的软件技术 解决矛盾——OS的软件技术：多道程序设计技术、分时技术、资源分配与调度等 (3) 计算机体系结构与硬件技术的变化 单CPU计算机—\u003e多处理机系统、消息传递型计算机、计算机网络 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.2 操作系统的形成与发展 手工操作阶段——无软件；特点：有人工干预、独占性、串行性；CPU速度提高后存在人机矛盾 批处理阶段 联机批处理： ① 特点 监督程序、作业自动过渡 ② 问题 CPU高速与I/O慢速的矛盾 ③ 解决办法 由卫星机负责I/O 脱机批处理： ① 特点 主机与卫星机并行操作 ② 问题 调度不灵活；保护问题 ③ 解决办法 硬件技术的发展——通道技术、中断技术 执行系统：借助于通道与中断技术，由主机控制I/O工作。原有的监督程序不仅要负责调度作业自动地运行，而且还要提供I/O控制功能。它常驻主存，称为执行系统。 特点 主机、外设并行操作；增强了保护能力 基本功能 ​ I/O控制功能 调度 问题 主机与外设的并行是有限度的，还依赖于程序运行的特征 操作系统的形成 (1) 多道程序设计技术：在计算机主存中同时存放几道相互独立的程序。这些程序在管理程序控制之下，相互穿插地运行。当某道程序因某种原因不能继续运行下去时(如等待外部设备传输数据)，管理程序便将另一道程序投入运行。 特点：多道、宏观上并行、微观上串行 (2) 分时技术：是把处理机时间划分成很短的时间片(如几百毫秒)轮流分配给各个应用程序使用，如果某个程序在分配的时间片用完之前计算还未完成，该程序就暂时中断，等待下一轮继续计算。 分时处理 ：一台计算机与许多终端设备连接，终端用户以联机方式使用计算机。 (3) 实时处理：计算机对于外来信息能够在被控对象允许的截止期限 (deadline)内作出反应。以快速反应为特征、具有实时性和可预测性。 计算机体系结构与操作系统的关系(续) (1) 单CPU计算机配置的操作系统 批量操作系统 分时操作系统 实时操作系统 个人计算机操作系统 (2) 具有并行结构的计算机系统配置的操作系统 网络操作系统 (计算机网络，松耦合) 多处理机操作系统 (多处理机系统，紧耦合) 集群操作系统 (分布存储的多计算机系统 ) 并行分布式系统 (分布存储的多计算机系统) 分布式系统 (具有单一用户界面，支持分布式数据处理 ) 分布式实时系统 (支持分布式实时数据处理 ) 硬件技术的进步——通道和中断极大地促进了OS的发展 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.3 操作系统的定义 资源共享与资源竞争 (1) 资源共享：多个计算任务对计算机系统资源的共同享用 (2) 资源竞争：多个计算任务对计算机系统资源的争夺 操作系统的定义与特征 定义：操作系统是一个大型的程序系统，是核心系统软件，它负责计算机系统软、硬件资源的分配和使用；控制和协调并发活动；提供用户接口，使用户获得良好的工作环境。 特征： ① 并发 并行性，又称共行性，是指能处理多个同时性活动的能力 ② 共享 多个计算任务对系统资源的共同享用 ③ 不确定性 操作系统能处理大量的、随机的事件序列，操作系统可以处理多种可能的事件序列，使各用户的计算任务正确地完成 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.4 操作系统的资源管理功能 处理机管理 CPU是计算机中最重要的资源，CPU管理核心问题是时间的分配。 (1) 确定进程调度策略：确定将CPU先分给哪个用户程序，它占用多长时间，下一个又该轮到哪个程序运行等问题。 (2) 给出进程调度算法 (3) 进行处理机的分派：在调度时机到来时，进行处理机分派。 存储器管理 主存空间 (1) 存储分配和存储无关性：确定各应用程序在主存中的位置及所占区域的大小；应用程序无需关心存储细节，由存储管理模块提供地址重定位能力。 (2) 存储保护：系统提供基址、界限寄存器等存储保护方法，使各应用程序相互隔离。 (3) 存储扩充：系统提供虚拟存储技术，扩大逻辑主存。 设备管理 (1) 设备无关性 设备无关性是指用户向系统申请和使用的设备与实际操作的设备无关，以达到 方便用户、提高设备利用率的目的。 (2) 设备分配 操作系统为各应用程序和运行实体分配各种设备。设备分配通常采用三种基 本技术：独享、共享及虚拟技术。 (3) 设备的传输控制 设备的传输控制包括：启动设备、中断处理、结束处理三个方面。 信息管理(文件系统/软件资源管理) 文件系统为用户提供一种简便的、统一的存取和管理信息的方法，并解决信息的共享、数据的存取控制和保密等问题。 具体而言，文件系统要实现： 用户的信息组织 提供存取方法 实现文件共享 文件安全 文件完整性 磁盘空间分配 操作系统的资源管理观点 系统资源：处理机 存储器 I/O设备 软件资源 (分别对应……) 操作系统功能模块：处理机管理 存储器管理 设备管理 文件系统 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.5 操作系统的基本类型 批量操作系统：批量操作系统是操作系统的一种类型。该系统把用户提交的程序组织成作业形式。作业成批送入计算机，然后由作业调度程序自动选择作业，在系统内多道运行。早期计算机一般都配置批量操作系统。 批量操作系统特点: ① 系统吞吐率高：脱机操作、多道运行、合理搭配作业 ② 作业周转时间长，用户使用不方便 分时操作系统：分时操作系统是操作系统的另一种类型。它一般采用时间片轮转的办法，使一台计算机同时为多个终端用户服务。该系统对每个用户都能保证足够快的响应时间，并提供交互会话功能。 分时操作系统的特点：① 并行性 ② 独占性 ③ 交互性 实时操作系统：实时操作系统对外部输入的信息，能够在规定的时间内处理完毕并作出反应。配置了实时操作系统的系统称为实时系统，该系统是可以对科学实验、医学成像、工业控制、武器装备控制和特定显示系统进行实时控制的系统。 实时系统分类： ⅰ 硬实时系统 系统必须满足应用程序对截止期限(deadline)的要求，若错过了截止期限，将导致灾难性后果。 ⅱ 软实时系统 系统中截止期限被错过的情况下，只造成系统性能下降而不会带来严重后果 实时操作系统的特点：可靠性和安全性、及时响应 实时操作系统的类型： 实时控制——生产过程控制、作战控制 实时信息处理——订购机票、情报检索 个人计算机操作系统 不再是最大化CPU和外设的利用率，而是最大化用户方便性和响应速度 代表： (1) 磁盘操作系统 MS-DOS：包括设备管理、文件系统、提供键盘命令和系统调度命令 (2) Windows系统：图形用户界面、多任务多线程、可剥夺式调度、段页式虚拟存储管理技术、动态连接 (3) UNIX系统：多用户分时操作系统、可移植性、安全性、大量用于网络服务器 多处理机系统 也称并行系统/紧耦合系统 (1) 多处理机系统的定义 ① 包含两个或多个功能相当的处理器 ② 所有处理器共享一个公共内存 ③ 所有处理器共享I/O通道、控制器和外围设备 ④ 由一个操作系统控制 (2) 多处理机系统的特点 具有并行处理能力 紧耦合、存在瓶颈、可扩展性差 不支持大规模并行计算；不支持分布处理 网络操作系统 计算机网络：线路将一些独立自治的计算机相互连接形成的一个集合体称为计算机网络；具有特点：① 多个处理部件② 无公共内存③ 具备消息通信机制 网络操作系统：除了具备一般操作系统应具有的功能模块外 (如系统核心、设备 管理、存储管理、文件系统等)，还要增加一个网络通信模块。该模块由通信接 口中断处理程序、通信控制程序以及各级网络协议软件组成。 计算机网络的局限性 ① 不能支持透明的资源存取 ② 不能对网络资源进行有效、统一的管理 ③ 不能支持合作计算 分布式系统 (1) 分布式系统的定义 ① 包含多个通用资源部件(物理资源和逻辑资源)，可以动态地分配给各个任务 ② 这些资源是物理分布的，并经过通信网络相互作用，进程通过相互合作的协议通信 ③ 有一个分布式操作系统对资源进行全局和动态的管理控制 ④ 系统的内部构造与分布性对用户是透明的，用户请求不需要指明为其服务的资源 ⑤ 所有资源高度自治地工作，而又相互配合，资源不存在层次控制与主从控制 (2) 分布式系统的特点 ① 可扩展性：用户需求增长可以通过增加新部件或新功能模块实现，不需要替换系统 ② 增加系统性能：多个部件可以实施物理并行操作 ③ 高可靠性：资源冗余以及结构可以动态重构 （更多特点：更高一级的资源共享、经济性好、适应性强） 嵌入式操作系统：嵌入式系统中的OS 嵌入式系统： 在各种设备、装置或系统中，完成特定功能的软硬件系统 它们是一个大设备、装置或系统中的一部分，这个大设备、装置或系统可以 不是“计算机” 通常工作在反应式或对处理时间有较严格要求环境中 由于它们被嵌入在各种设备、装置或系统中，因此称为嵌入式系统 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:5","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第二章 操作系统的结构和硬件支持 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"2.1 操作系统虚拟机 在裸机上配置了操作系统程序后就构了操作系统虚拟机。 操作系统的核心在裸机上运行；用户程序在扩充后的机器上运行。 (1) 裸机的指令系统：机器指令 (2) 操作系统虚拟机的指令系统 ① 操作命令 (又称命令接口) ​ 作业控制语言、键盘命令、图形化用户界面 ② 系统功能调用 (又称程序接口) ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"2.2 操作系统的结构 操作系统的结构设计模式 (课本上分类为4种：单体结构、模块结构、可扩展内核结构、层次结构) 单体结构：操作系统是一组过程的集合，每一过程有定义好的接口。过程间可以相互调用而不受约束。 操作系统运行效率高 缺点是难以理解、难以维护，验证正确性十分困难 例如AT\u0026T System V与BSD UNIX内核 模块结构：功能通过逻辑独立的模块划分，系统作为抽象数据类型或对象方法来实现 有利于操作系统的理解和维护 缺点是潜在的性能退化 例如Choices 可扩展内核结构：将操作系统内核分为基础核心和其他核心功能两部分 支持两个新方向：在单一硬件平台上建立具有不同策略的操作系统；微内核操作系统 例如Mach、Tru64 UNIX、QNX 层次结构：操作系统由若干层组成，每层提供一套功能，且该功能仅仅依赖于该层以内的各层 例如THE (老师给出的分类) 简单结构 MS-DOS – 在最小的空间，设计用于提供大部分功能 (1981~1994) 没有拆分为模块 接口和功能程序没有很好地分离 主要用汇编语言编写 缺点：不方便移植，与硬件紧密绑定 层次化结构 ■ 将操作系统分为多层 (levels) ​ 每层建立在低层之上 ​ 最底层(layer 0), 是硬件 最高层(layer N) 是用户界面 ■ 每一层仅使用更低一层的功能（操作）和服务。 优点: 方便移植（底层依旧采用汇编语言，上层则可以采用高级语言） 缺点: 效率低 微内核结构 ■ 尽可能把内核功能移到用户空间 ■ 用户模块间的通信使用消息传递（基于客户/服务器模型） 优点: 灵活/安全… 缺点: 性能下降 外核结构 ■ 让内核分配机器的物理资源给多个应用程序, 并让每个程序决定如何处理这些资源. ■ 程序能链接到操作系统库(libOS) 实现了操作系统抽象 ■ 保护与控制分离 虚拟机的早期雏形 VMM(虚拟机管理器) 多操作系统共享硬件资源 …… 操作系统结构实例 1）Linux系统的核心结构 Windows操作系统的结构 运行时的组织结构 在操作系统运行过程中调用给定的操作系统内部例程有2种方式： 系统功能调用方式 库函数(实际是隐式的内核功能调用) 客户端/服务器方式 将操作系统服务作为系统服务进程来提供，服务请求和服务响应是通过消息传递来实现的。 ​ 优点：支持分布式系统，支持不同服务类型，容错性好，易于维护 ​ 缺点：需维护必要的持久性进程，这些进程需要监听和相应各种不同的请求。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"2.3 处理机的特权级 为什么要区分处理机的状态 保护操作系统：用户程序运行时需要提出资源请求，不能随意启动外部设备工作、改变状态等 处理机状态分类 管态：操作系统的管理程序执行时机器所处的状态，又称处理机的特权级。在此状态下处理机可使用全部指令(包括一组特权指令)；使用全部系统资源(包括整个存储区域)。 用户态：用户程序执行时机器所处的状态称为用户态。在此状态下禁止使用特权指令，不能直接取用资源与改变机器状态，并且只允许用户程序访问自己的存储区域。 处理机状态特权指令集 ① 涉及外部设备的输入/输出指令 ② 修改特殊寄存器的指令 ③ 改变机器状态的指令 用户态转向管态的情况 ① 用户进程申请系统的某种服务即系统功能调用 ② 用户程序执行时发生中断 ③ 用户进程中产生错误状态（程序性中断） ④ 用户态下企图执行特权指令，作为特殊类型错误并按③处理 管态转向用户态是通过一条特权指令实现的。 实例操作系统处理机的状态 ① DOS系统 不分态 ② Windows 系统 3环 用户态 0环 系统态 还有1、2环预留 ③ UNIX系统 (Linux)系统 00 核态(核态有原管态全部权限) 01 管态(核态存在时，管态不能使用修改状态指令) 11 用户态 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"2.4 中断及其处理 中断：指某个事件 (例如电源掉电、定点加法溢出或I/O传输结束等) 发生时，系统中止现行程序的运行、引出处理事件程序对该事件进行处理，处理完毕后返回断点继续执行的过程。 中断类型 (1) 按中断功能分类 ① 输入输出中断 I/O传输结束或出错中断 ② 外中断 时钟中断、操作员控制台中断、通信中断等 ③ 机器故障中断 电源故障、主存取指令错等 ④ 程序性中断 定点溢出、用户态下用核态指令、非法操作 ⑤ 访管中断 对操作系统提出某种需求时所发出的中断 (2) 按中断方式分类 ① 强迫性中断 不是正在运行的程序所期待的中断。 如：输入输出中断、外中断、机器故障中断、程序性中断 ② 自愿中断 是运行程序所期待的事件。 如：访管中断 (3) 按中断来源分类 ① 中断 由处理机外部事件引起的中断(x86中称为异步中断)，包括I/O中断、外中断。 ② 俘获 由处理机内部事件引起的中断(x86中称为异常，也称为同步中断)，包括访管中断、程序性中断、机器故障中断。 在同时发生中断和俘获请求时，俘获总是先得到相应和处理。 向量中断：根据中断源设置的中断向量，通过消耗主存的中断向量表进入对应中断处理程序。中断处理时间比探询向量大大缩短。 探询中断：中断响应转入某一大类中断的处理入口程序 中断响应（中断进入） (1) 保护现场和恢复现场 现场：在中断的那一时刻能确保程序继续运行的有关信息。 ​ ⅰ 后继指令所在主存的单元号 ​ ⅱ 程序运行所处的状态 ​ ⅲ 指令执行情况 ​ ⅳ 程序执行的中间结果等 保护现场：当中断发生时，必须立即把现场信息保存在主存中，这一工作称之为保护现场。 恢复现场：程序重新运行之前，把保留的该程序现场信息从主存中送至相应的指令计数器、通用寄存器或一些特殊的寄存器中。完成这些工作称为恢复现场。 (2) 程序状态字 (PSW) ① 定义 反映程序执行时机器所处的现行状态的代码。 ② 内容 指令地址、指令执行情况、处理机状态、应屏蔽的中断等。 ③ 程序状态字的例子 ⅰ IBM 370 机(大型机) 程序状态字内容 → PSW寄存器 ⅱ IBM PC 机(x86) 程序状态字内容 → CS IP 指令地址；flag 标志寄存器 ⅲ PDP 11系列机 程序状态字内容 → PC 指令计数器；PS 处理器状态寄存器 (3) 什么是中断响应 中断响应是当中央处理机发现已有中断请求时，中止现行程序执行，并自动引出中断处理程序的过程。 实质：交换用户程序和处理该中断事件的中断处理程序的指令执行地址和处理机状态，以达到如下目的：保留程序断点及有关信息；自动转入相应的中断处理程序。 (4) 中断响应所需的硬件支持 指令计数器、处理器状态寄存器、中断向量表和系统堆栈 软件中断处理 当硬件完成了中断进入过程后，由相应的中断处理程序得到控制权，进入了软件的中断处理过程。软件的中断处理过程主要包括： ① 保护现场和传递参数 ② 执行相应的中断（或自陷）服务例程 ③ 恢复和退出中断 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第三章 操作系统的用户接口 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.1 用户工作环境 用户工作环境的形成 (1) 系统提供各种硬件、软件资源 (2) 设计并提供使用方便的命令集合 (3) 将OS装入计算机并初始化，形成可供使用的工作环境 操作系统的初启 (1) 系统引导的任务 将操作系统的必要部分装入主存并对系统进行初始化工作，最终使系统处于命令接收状态。 (2) 系统引导的方式 ① 现场独立引导方式(滚雪球方式， bootup) OS核心文件存储在系统本身的存储设备中，由系统自己将OS核心程序读入主存并运行，建立一个操作环境。适用于微机和大多数系统 ② 辅助下装方式（ download ） OS主要文件不放在系统本身的存储设备中，在系统启动后执行下装操作，从另外的计算机系统中将操作系统常驻部分传送到该计算机中，使它形成一个操作环境。 适用于多计算机系统、由主控机与前端机构成的系统以 及分布式系统。 (3) 独立引导方式 (滚雪球方式) 的过程 ① 初始引导 系统加电； 执行初始引导程序，对系统硬件和配置进行自检，保证系统没有硬件错误； 从硬盘中读入操作系统引导程序，并将控制权交给该程序模块。 ② 引导程序执行 引导程序执行，将操作系统核心文件读入内存，并将控制交给核心的初始化程序。 ③ 核心初始化 初始化系统数据结构及参数 系统加电建立进程有关的数据结构 ； 获得自由存储空间的容量，建立存储管理的数据结构 ； 建立系统设备和文件系统的数据结构 ； 初始化时钟。 ④ 系统初始化 完善OS的操作环境，装载命令处理程序 (或图形用户界面)，并初始化； 在多用户系统中，为每个终端建立命令解释进程，使系统处于命令接收状态。 (4) *Linux系统初启 Linux系统是以滚雪球的方式启动 加电或复位 → BIOS的启动 → Boot Loader → OS初始化 ① 系统加电或复位 对主存中所有的数据清零，对内存进行校验，若无错， CS：IP → BIOS入口。 ② BIOS启动 在ROM中的引导程序放在固定位置：FFFF：0000 CPU从这里开始执行。 上电自检； 对硬件设备进行检测和连接，并将测得的数据送入BIOS数据区； 从盘中读入Boot Loader (引导程序)。 从硬盘启动时，读入零柱面零磁道1扇区MBR (Master Boot Record)，将控制权交Boot Loader。 ③ Loader(引导程序) 功能：将OS读入内存，并将控制权交给OS的初始化程序。 ④ 系统核心初始化( Setup.s) Setup的工作 检查调入内存中的代码 ； 获取内存容量信息，设置设备模式； 屏蔽中断，准备进入保护模式； 设置中断描述符表 (idt)，全局描述符表 (gdt)；控制权交给 Heads。 Heads的工作 对中断向量表作准备工作； 检查CPU类型； 调用Setup_paging进行页面初始化； 调用main.c中的Start_kernel()。 ​Start_kernel()的工作 ​ 对与CPU、内存等最基本硬件相关部分进行初始化； ​ 对中断向量表进行初始化； ​ 为进程调度程序作准备； ​ 设置基准时钟； ​ 内核的内存分配； ​ 对文件系统进行初始化； ​ 建立init进程。 ​ init进程对每一个联机终端建立“getty”进程，getty在终端上显示“login”，等待用户登录。 系统生成 (1) 什么是系统生成 所谓系统生成，就是指为了满足物理设备的约束和需要的系统功能，通过组装一批模块来产生一个清晰的、使用方便的操作系统的过程。 (2) 系统生成的内容 根据硬件部件确定系统构造的参数，编辑系统模块的参数，并且连接系统模块成为一个可执行的程序。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.2 应用程序的处理 处理应用程序的步骤 (1) 编辑 建立一个新文件，或对已有的文件中的错误进行修改。 (2) 编译 将源程序翻译成浮动的目标代码。 (3) 连接 主程序和其他所需要的子程序和例行程序连接装配在一起，使之成为一个可执行的、完整的主存映像文件。 (4) 运行 将主存映像文件调入主存，启动运行，得出计算结果。 这四个步骤相互关联、顺序执行：每个步骤处理的结果产生下一个步骤所需要的文件；一个步骤能否正确地执行，依赖于前一个步骤是否成功地完成。 连接类型 (1) 静态连接 一个源程序经编译后，生成一个可重定位的目标模块，并产生内部符号表和外部符号表，供连接程序 (Link)使用。 ① 内部符号表 ​ 本模块可以被其他程序调用的入口点。 ② 外部调用表 ​ 本模块要调用的外部的程序模块名。 ③ 连接需要做的工作 将各模块连接成为一个整体； 构造全程符号表，在其中填写模块的逻辑地址； 查找各程序段的外部调用表，填入对应调用函数的地址。 ④ 静态连接的缺点 静态连接将所需的外部函数链接到目标文件中形成为一个可执行文件。若多个应用程序都调用了同一个库中的外部函数，那么，多个应用程序的目标文件中都会包含这个外部函数对应的代码。 (2) 动态连接 动态连接不需要将外部函数链接到目标文件中。而是在应用程序中需要调用外部函数的地方作记录，并说明要使用的外部函数名和引用入口号，形成函数调用链表。 所需支持 —— DLL (动态链接库) 当 Windows的装载程序将应用程序和DLL装入主存后，装载程序会遍历函数调用链表，将DLL中函数在主存的入口 (段：偏移)填入链表中的每个结点。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.3 用户接口 什么是操作系统的用户界面 操作系统的用户界面 (或称接口) 是操作系统提供给用户与计算机打交道的外部机制。用户能够借助这种机制和系统提供的手段来控制用户所在的系统。 操作系统提供的用户界面 (1) 操作界面 (命令接口) 用户使用操作界面来组织工作流程和控制程序的运行。 (2) 系统功能服务界面 (程序接口) 用户程序在其运行过程中，使用系统功能调用来请求操作系统的服务。 操作命令与操作系统类型的关系 (1) 作业控制语言 ─ ─ 批处理操作系统 (2) 键盘命令 ─ ─ 分时操作系统、个人计算机操作系统 (3) 图形用户界面 ─ ─ 分时操作系统、个人计算机操作系统 第一种：作业控制语言（JCL） 一种命令语言，包括作业处理命令和资源请求命令 脱机方式下系统提供作业控制语言 批处理系统中作业的组成 作业申请：作业名、需用CPU时间、最迟完成时间、资源请求（主存、外设）等 操作说明书：编辑命令、编译命令、连接命令、运行命令等 程序与数据 第二种：键盘命令 操作系统为联机用户提供的一种操作命令，用户通过这一组 命令直接控制和干预程序的运行 系统为联机用户提供键盘命令 键盘命令的功能 分时操作系统 —— 用于注册、通信、注销的各类命令 个人计算机操作系统 —— 用于通信的各类命令 分时系统中用户通过键盘直接向系统发布各种命令 Windows系统的键盘命令 内部命令:系统的命令程序command.com中 外部命令:所有可执行文件的文件名 .exe（大模式执行文件） .com（小模式执行文件） .bat（批处理文件） Linux/UNIX系统的键盘命令 基本命令:命令的可执行文件均在/bin目录下 高级命令:可执行文件名,存放在文件中 第三种： 图形用户界面 • 菜单驱动方式 面向屏幕的交互方式，将键盘命令以屏幕方式来体现；命令和系统能完成的操作，用菜单分类分窗口列出；用户像点菜一样选择命令或某种操作，以控制系统去完成指定的工作；菜单系统的类型有多种，如下拉式菜单、上推式菜单和随机弹出式菜单 • 图符驱动方式 图符（Icon）也称图标，是一个小小的图符符号，代表操作系统中的命令、系统服务、操作功能、各种资源。 良好的用户交互界面，将菜单驱动、图符驱动、面向对象技术等集成在一起，形成一个图文并茂的视窗操作环境。 图形用户界面的特点 • 所有程序以统一的窗口形式出现 • 提供统一的菜单格式 • 系统资源、系统命令、操作功能以图标表示 • 统一的操作方法 实例操作系统提供的用户界面 (1) MS-DOS ─ ─ 键盘命令、系统功能调用 (2) Windows ─ ─ 图形用户界面、系统功能调用 (3) Linux (UNIX) ─ 键盘命令 (XWindow)、系统功能调用 程序接口 系统功能调用是针对程序设计者而提供的操作系统服务方式，在采用面向对象技术的系统中，为程序员提供的是API（应用程序编程接口）函数和系统定义的消息形式。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.4 系统功能调用 系统功能调用 系统功能调用是操作系统提供的程序接口，是操作系统命令集中的一部分 定义：系统功能调用是用户在程序一级请求操作系统服务的一种手段，它是带有一定功能号的“访管指令”。其功能是由操作系统中的程序完成的，即由软件方法实现的。 (1) 操作系统在设计时，确定和编制好能实现用户需要的各种功能的例行子程序 (2) 如何调用操作服务功能 ​采用统一进管方式 —— 系统提供 访管指令、访管中断 访管指令 (自愿进管指令) ​是一条机器指令，是裸机提供的接口，是通过硬件实现的。 ​svc n svc 表示机器访管指令的操作码记忆符，n为地址码 (功能号) 访管中断 ​当处理机执行到访管指令时发生中断，该中断称为访管中断，它表示正在运行的程序对操作系统的某种需求。 系统功能调用的实现 实现这种服务是由系统服务请求机构提供的，系统服务请求(SSR)机构实质是一个自陷门，SSR的执行通常取决于计算机的结构。 不同的操作系统，系统调用实现的具体方法有所不同，但其实质特点相同： 每个系统调用对应一个系统调用号 每个系统调用有一个对应的执行程序段 每个系统调用要求一定数量的输入参数和返回值 整个系统有一个系统调用执行程序入口地址表 应用程序的编程接口 在任何操作系统中，系统调用是用户空间访问内核的唯一手段 应用程序用低级语言编程，可以直接调用系统调用，称为显示方式调用； 应用程序用高级语言编程，采用API函数、标准C库函数使用系统调用，称为隐式方式调用 系统功能调用 vs. 库函数 库函数：由软件开发商提供，由编译链接工具链入用户程序，有的库函数不涉及系统调用，有的库函数则会隐式地发出系统调用请求 系统调用：代码属于OS，系统调用代码执行时使CPU的状态由用户态变为核心态（管态） 在程序设计语言(如C语言)中，往往提供与各系统调用对应的库函数，应用程序可通过对应的库函数来使用系统调用 库函数的目的是隐藏访管指令细节，使系统调用更象过程调用，但一般地说，库函数属于用户程序而非系统程序 操作系统为用户提供系统调用也出于安全和效率考虑，使得用户态程序不能自由地访问内核关键数据结构或直接访问硬件资源 系统调用与过程(函数) 调用的区别 ​ 调用形式 ​ 被调用代码的位置 ​ 提供方式 ​ 调用的实现 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第四章 进程及进程管理 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.1 进程的引入 顺序程序及特点 (1) 程序与计算 程序是为解决某一问题而设计的一系列指令的集合，是算法的形式化描述。 程序的依次执行过程称为一个计算，它由若干简单的操作组成。 (2) 程序的顺序执行 一个计算的若干操作必须按照严格的先后次序顺序地执行，这类计算过程就是程序的顺序执行过程。 顺序程序：一个程序由若干个程序段组成，若这些程序段的执行必须是顺序的，这个程序被称为顺序程序。 (3) 顺序程序的特点 顺序性 —— 处理机的操作严格按照程序所规定的顺序执行。 封闭性 —— 程序一旦开始执行，其计算结果不受外界因素的影响。 可再现性 —— 程序拥有与时间无关性：程序执行的结果与它的执行速度无关 (即与时间无关)，而只与初始条件有关。所以具有可再现性，即只要给定相同的输入条件，程序重复执行一定会得到相同的结果。（与时间无关性的先决条件：程序自身是封闭的，即变量、指针、各资源的状态不被外界改变） 并发程序 (1)程序的并发执行 若干个程序段同时在系统中运行，这些程序段的执行在时间上是重叠的，一个程序段的执行尚未结束，另一个程序段的执行已经开始，即使这种重叠是很小的一部分，也称这几个程序段是并发执行的。 并行语句记号 cobegin S1；S2；… ；Sn ； coend (2)并发程序的特点 ① 失去程序的封闭性和可再现性 ​ 若一个程序的执行可以改变另一个程序的变量，那么，后者的输出就可能有赖于各程序执行的相对速度，即失去了程序的封闭性特点。 ② 程序与计算不再一一对应 ​ 一个程序可以对应多个计算。多个计算任务共享某个程序时，都可以调用这个程序，且一次调用就是一次计算，因而这个程序可执行很多次，即这个共享的程序对应多个计算。 ③ 程序并发执行的相互制约 ​ 间接的相互制约关系 —— 资源共享 ​ 直接的相互制约关系 —— 公共变量 与时间有关的错误 程序并发执行时，若共享了公共变量，其执行结果与各并发程序的相对速度有关，即给定相同的初始条件，若不加以控制，也可能得到不同的结果，此为与时间有关的错误。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.2 进程概念 进程定义(进程有着多种定义) 进程：就是一个程序在给定活动空间和初始环境下，在一个处理机上的执行过程，是一个动态的概念。 是指一个具有一定独立功能的程序关于某个数据集合的一次运行活动。 是程序与其数据一道通过处理机的执行所发生的活动。 进程与程序的区别 ① 程序是静态的概念，进程是动态的概念； ② 进程是一个独立运行的活动单位； ③ 进程是竞争系统资源的基本单位； ④ 一个程序可以对应多个进程，一个进程至少包含一个程序 进程的状态 (1)进程的基本状态 ​① 运行状态(running) ​ 该进程已获得运行所必需的资源，它的程序正在处理机上执行。 ​② 等待状态(wait) ​ 进程正等待着某一事件的发生而暂时停止执行。这时，即使给它CPU控制权，它也无法执行。 ​③ 就绪状态(ready) ​ 进程已获得除CPU之外的运行所必需的资源，一旦得到CPU控制权，立即可以运行 (2)进程的状态变迁 变迁1——\u003e 变迁3，是否会发生？需要什么条件？ 变迁4——\u003e 变迁3，是否会发生？需要什么条件？ (3) 讨论在多进程操作系统环境下程序的执行 ① 例1：讨论3个排序程序在不同的操作系统环境中执行结果 程序A：冒泡排序算法，在屏幕的左1/3处开设窗口显示其排序过程； 程序B：堆排序算法，在屏幕的中1/3处开设窗口显示其排序过程； 程序C：快速排序算法，在屏幕的右1/3处开设窗口显示其排序过程。 讨论在不支持多进程的操作系统下运行和在支持多进程的操作系统下运行的情况 ⅰ在不支持多进程的操作系统下运行 依次运行程序A、程序B、程序C。 ⅱ 在支持多进程的操作系统下运行 建立进程A、B、C；对应的程序分别是程序A、B、C； 若系统采用时间片轮转的调度策略，则在屏幕上有3个窗口，同时显示3个排序过程。 实际上这3个程序在轮流地占用CPU时间，由于CPU的高速度，使我们看到的是这3个程序在同时执行 ② 例2：讨论2个程序在不同的操作系统环境中执行结果 程序C：打印工资报表的程序； 程序D：计算1000以内所有素数并显示最后结果。 讨论在不支持多进程的操作系统下运行和在支持多进程的操作系统下运行。 ⅰ在不支持多进程的操作系统下运行 依次运行程序C、程序D，可以看到，先是打印机不停地打印工资报表，打完后，接着运行程序C，不停地计算，最后显示所计算的结果。 ⅱ 在支持多进程的操作系统下运行 建立进程C、D；对应的程序分别是程序C、D； 由于进程C是I/O量较大的进程，而进程D是计算量较大的进程，故在系统进程调度的控制下，两个进程并发执行。可以看到打印机不断打印工资报表；而处理机不停地计算，最后屏幕显示计算的结果。 进程描述 (1) 进程控制块 描述进程与其他进程、系统资源的关系以及进程在各个不同时期所处的状态的数据结构，称为进程控制块PCB (process control block)。 进程控制块的主要内容有： ① 进程标识符 进程符号名或内部 id号 ② 进程当前状态 本进程目前处于何种状态 ③ 当前队列指针next 该项登记了处于同一状态的下一个进程的 PCB地址。 ④ 进程优先级 ​ 反映了进程要求CPU的紧迫程度。 ⑤ CPU现场保护区 ​ 当进程由于某种原因释放处理机时，CPU现场信息被保存在PCB的该区域中。 ⑥ 通信信息 ​ 进程间进行通信时所记录的有关信息。 ⑦ 家族联系 ​ 指明本进程与家族的联系 ⑧ 占有资源清单 (2) 进程的组成 ① 程序与数据 描述进程本身所应完成的功能 ② PCB ​ 进程的动态特征，该进程与其他进程和系统资源的关系 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.3 进程控制 进程控制的概念 (1) 进程控制的职责 对系统中的进程实施有效的管理，负责进程状态的改变。 ① 进程状态变化 创建 撤销 无——\u003e有——\u003e消亡 ​ 等待 运行——\u003e等待 唤醒 等待------\u003e就绪 ② 常用的进程控制原语**(原语：执行时不可中断，权限很高)** ​ 创建原语、撤消原语、阻塞原语、唤醒原语 (2) 进程创建 ① 进程创建原语的形式 create (name，priority) name为被创建进程的标识符 priority为进程优先级 ② 进程创建原语的功能 创建一个具有指定标识符的进程，建立进程的PCB结构。 ③ 进程创建原语的实现 (3) 进程撤销 ① 进程撤销原语的形式 当进程完成任务后希望终止自己时使用进程撤消原语。 Kill (或exit) ② 进程撤销原语的功能 撤消当前运行的进程。将该进程的PCB结构归还到PCB资源池，所占用的资源归还给父进程，从总链队列中摘除它，然后转进程调度程序。 ③ 进程撤销原语的实现 (4) 进程等待 ① 进程等待原语的形式 当进程需要等待某一事件完成时，它可以调用等待原语挂起自己。 susp(chan) 入口参数chan：进程等待的原因 ② 进程等待原语的功能 中止调用进程的执行，并加入到等待chan的等待队列中；最后使控制转向进程调度 ③ 进程等待原语的实 (5) 进程唤醒 ① 进程唤醒原语的形式 当处于等待状态的进程所期待的事件来到时，由发现者进程使用唤醒原语唤醒它 wakeup(chan) 入口参数chan：进程等待的原因。 ② 进程唤醒原语的功能 当进程等待的事件发生时，唤醒等待该事件的进程。 ③ 进程唤醒原语的实现 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.4 进程之间的约束关系 进程互斥的概念 (1) 临界资源：一次仅允许一个进程使用的资源称为临界资源。 ​硬件：如输入机、打印机、磁带机等 ​软件：如公用变量、数据、表格、队列等 (2) 临界区：临界区是进程中对公共变量 (或存储区)进行审查与修改的程序段，称为相对于该公共变量的临界区。 ​临界区是针对某一临界资源而言的；相对于某临界资源的临界区个数就是共享该临界资源的进程个数；相对于某个公共变量的若干个临界区，必须是互斥地进入。 ​有若干进程欲进入其临界区时，应在有限时间内使进程进入临界区，不能相互阻塞；每次至多有一个进程处于某一临界资源的临界区；进程仅在临界区内停留有限时间。 (3) 进程互斥：在操作系统中，当某一进程正在访问某一存储区域时，就不允许其他进程来读出或者修改存储区的内容，否则，就会发生后果无法估计的错误。进程间的这种相互制约关系称为互斥。 进程同步的概念 进程同步：并发进程在一些关键点上可能需要互相等待与互通消息，这种相互制约的等待与互通消息称为进程同步。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.5 进程同步机构 进程在信息共享和并行处理两种情况下需要协作，协调各进程前进的步伐。 操作系统提供实现进程协作的措施和方法，称为同步机构。有如下两种： ① 锁和上锁、开锁操作； ② 信号灯（或称信号量）和P、V操作。 锁和上锁、开锁操作 (1) 什么是锁 用变量w代表某种资源的状态，w称为“锁” 。 (2) 上锁操作和开锁操作 检测w的值 (是0还是1)； 如果w的值为1，继续检测； 如果w的值为0，将锁位置1 (表示占用资源)，进入临界区执行。 (此为上锁操作) 临界资源使用完毕，将锁位置0。 (此为开锁操作) (3) 进程使用临界资源的操作 (4) 上锁原语和开锁原语 ① 上锁原语 lock //算法 lock //输入：锁变量w //输出：无 { test: if (w为1) goto test;/* 测试锁位的值 */ else w=1;/* 上锁 */ } ② 开锁原语 unlock //算法 unlock //输入：锁变量w //输出：无 { w=0; /*开锁*/ } 信号灯和P、V操作 (1) 信号灯:一个确定的二元组 (s，q)，s是一个具有非负初值的整型变量，q是一个初始状态为空的队列。操作系统利用信号灯的状态对并发进程和共享资源进行控制和管理。 信号灯是整型变量。 变量值 ≥ 0 时，表示绿灯，进程执行； 变量值 \u003c 0 时，表示红灯，进程停止执行。 注意：创建信号灯时，应准确说明信号灯 s 的意义和初值(这个初值绝不能为负值)。 (2) P 操作 ① P 操作的定义 对信号灯s的 p操作记为 p(s)。p(s)是一个不可分割的原语操作，即取信号灯值减1，若相减结果为负，则调用p(s)的进程被阻，并插入到该信号灯的等待队列中，否则可以继续执行。 ② P 操作的实现 (3) V 操作 ① V 操作的定义 对信号灯s的 v操作记为 v(s)。v(s)是一个不可分割的原语操作，即取信号灯值加1，若相加结果大于零，进程继续执行，否则，要帮助唤醒在信号灯等待队列上的一个进程。 ② V 操作的实现 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:5","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.6 进程互斥和同步的实现 用上锁原语和开锁原语实现进程互斥 (1) 框图描述 (2) 程序描述 用信号灯的P、V操作实现互斥 (1) 框图描述 (设：mutex为互斥信号灯，初值为1。) ![在这里插入图片描述](https://img-blog.csdnimg.cn/20201225191736759.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzgwOTYyNA==,size_16,color_FFFFFF,t_70#pic_center) (2) 程序描述 (3) 信号灯可能的取值 两个并发进程，互斥信号灯的值仅取1、0和－1三个值。 mutex=1 表示没有进程进入临界区； mutex=0 表示有一个进程进入临界区； mutex=－1 表示一个进程进入临界区，另一个进程等待进入。 两类同步问题解法 (1) 合作进程的执行次序 (2) 共享缓冲区的合作进程的同步的解法 生产者——消费者问题 (1) 生产者——消费者问题的例子 ① 计算进程和打印进程 计算进程 cp不断产生数据，是生产者； 打印进程 iop不断打印数据，是消费者。 ② 通信问题 发消息进程 send不断产生消息，是生产者； 收消息进程 receive不断接收消息，是消费者。 (2) 生产者——消费者问题的一般解答 ① 生产者——消费者问题图示 ② 生产者与消费者的同步关系 生产者：当有界缓冲区中无空位置时，要等待；向有界缓冲区放入物品后，要发消息。 消费者：当有界缓冲区中无物品时，要等待；从有界缓冲区取出物品后，要发消息。 ③ 信号灯设置 ⅰ 两个同步信号灯—— sb ：表示空缓冲区的数目，初值 = n sa ： 表示满缓冲区 (即信息)的数目，初值 = 0 ⅱ 一个互斥信号灯—— mutex：表示有界缓冲区是否被占用，初值 = 1 ④ 程序描述 扩展：理发师问题 理发店里有一位理发师、一把理发椅和n把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发椅上睡觉。当一个顾客到来时，他必须先叫醒理发师，如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，他们就坐下来等。如果没有空椅子，他就离开。 请用P、V操作为理发师和顾客各编写一段程序来描述他们的行为，要求不能带有竞争条件。 解答： 一个理发师，一把理发椅，n把等候理发的顾客椅子。 （1）如果没有顾客，则理发师在理发椅上睡觉； （2）当有一个顾客到达时，首先看理发师在干什么， 如果理发师在睡觉，则唤醒理发师理发； 如果理发师正在理发，则查看是否有空的顾客椅子可坐； 如果有顾客椅子可坐，则坐下等待，如果没有，则离开。 （3）理发师为一位顾客理完发后，查看是否有人在等待，如果有则唤醒下一位顾客理发，没有则理发师去睡觉。 理发师和顾客之间的同步关系 当理发师睡觉时，顾客进来需要唤醒理发师为其理发； 当有顾客时理发师为其理发，没有的时候理发师睡觉。 理发师与顾客、顾客与顾客之间的互斥关系 由于每次理发师只能为1个人理发，且可供等侯的椅子只有n把，即理发师和椅子是临界资源，顾客之间是互斥的关系 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:6","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.7 进程通信 进程通信(Interprocess Communication, IPC)：是指进程之间直接以较高的效率传递较多数据的信息交互方式。 IPC机制：指消息（message）从一个进程的地址空间拷贝到另一个进程的地址空间的过程，而不使用共享存储器。 进程通信方式：消息缓冲通信/信箱通信 (1) 消息缓冲通信 在消息通信中，接收方和发送方之间有明确的协议和消息格式 。大多数使用消息头：发送/接收进程的ID、被传消息的字节数…… ​消息缓冲通信方式包括消息缓冲、发送原语和接收原语。 ​ • 发送进程先形成一个消息缓冲区（含消息头和消息内容），然后用发送原语发出。 ​ • 接收进程在接收前，在本进程的主存空间设置一个接收区，然后用接收原语接收。 (2) 信箱通信 在信箱通信中，需要定义信箱结构，还包括消息发送和接收功能模块，提供发送原语和接收原语。 信箱通信中，所使用的信箱可以位于用户空间中，是接收进程地址空间的一部分；也可以放置在操作系统的空间中。 ​使用用户空间中的信箱实现消息传递： ​信箱由用户管理，进程可以直接访问信息； ​缺点：编译器和加载程序必须为每一个进程分配信箱空间；接收进程有可能覆盖信息的部分内容，从而造成错误。 ​使用系统空间中的信箱实现消息传递： ​信箱由OS管理，任何进程不能直接访问 ​缺点：要求OS为所有的进程分配主存信箱，受系统限制，可能对通信进程数限制。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:7","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.8 线程概念及特点 线程(threads)的引入 为了避免多处理机系统在进行远程访问期间的等待现象；线程就是进程的一个执行路径，一个进程可以有多条执行路径。这样，一个进程内部就有多个可以独立活动的单位，可以加快进程处理的速度，进一步提升并行处理能力。 (1) 线程定义：线程是比进程更小的活动单位，它是进程中的一个执行路径。 (2) 线程\u0026进程 联系与区别 线程可以这样来描述 ​ 进程中的一条执行路径； ​ 它有自己私用的堆栈和处理机执行环境 ； ​ 它与父进程共享分配给父进程的主存； ​ 它是单个进程所创建的许多个同时存在的线程中的一个。 ​ 进程是任务调度的单位也是系统资源的分配资源；而线程是进程中的一条执行路径，当系统支持多线程处理时，线程是任务调度的单位，但不是系统资源的分配单位。线程完全继承父进程占用的资源，活动时具有自己的运行现场。创建一个线程比创建一个进程开销要小得多。 线程可以用一个现场表示，现场由程序计数器、寄存器组合所要求的现场状态字符组成 线程的特点 线程是比进程更小的活动单位，它是进程中的一个执行路径。创建一个线程比创建一个进程开销要小得多。 实现线程间通信十分方便，因为一个进程创建的多个线程可以共享地址区域和数据。 线程是一个动态的概念。 在进程内创建多线程，可以提高系统的并行处理能力，加快进程的处理速度。 线程的状态变迁 4. 用户线程和内核线程 用户线程 在内核的支持下，在用户层通过线程库实现创建和调度在用户空间进行，无需内核干预 优点：能快速创建和管理 缺点：如果内核是单线程的，一旦一个用户线程执行了等待的系统调用，则整个进程阻塞 内核线程 ​ 由OS管理，创建和调度在OS主存空间内完成 ​ 当一个线程执行时阻塞，内核能调度另一个线程运行 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:8","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第五章 资源分配与调度 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.1 资源管理概述 资源：应用程序执行时所需要的全部硬件、软件和数据。 资源管理的目标：为用户提供一种简单有效地使用资源的方法，充分发挥各种资源的利用率，它应达到的目标是： 保证资源的高利用率。 ​ 在“合理”时间内使所有顾客有获得所需资源的机会。 ​ 对不可共享的资源实施互斥使用。 ​ 防止由资源分配不当而引起的死锁。 资源管理的任务 (1) 资源数据结构的描述：用于资源分配的数据结构应包含该类资源最小分配单位的描述信息，如资源的物理名、逻辑名、类型、地址、分配状态等信息。 (2) 确定资源的分配原则 (调度原则) 决定资源应分给谁，何时分配，分配多少等问题。 (3) 实施资源分配 执行资源分配；资源收回工作。 (4) 存取控制和安全保护 对资源的存取进行控制并对资源实施安全保护措施 资源资源的静态分配和动态分配 (1) 资源的静态分配 系统在调度作业时，根据作业所需资源进行分配；并在作业运行完毕时，收回所分配的全部资源。这种分配通常称为资源的静态分配。 (2) 资源的动态分配 系统在进程运行中，根据进程提出的资源需求，进行资源的动态分配和回收。这种分配通常称为资源的动态分配。 虚拟资源 (1) 操作系统对资源区分二种不同的概念 物理资源 (实资源) 虚拟资源 (逻辑资源) ：用户使用的逻辑资源，这是经过操作系统改造的、使用方便的虚资源，而不是物理的、实际的资源。 (2) 目的 资源可动态分配实现多用户共享，提高资源利用率，方便用户使用 如OS为用户提供逻辑地址空间、提供虚拟外部设备等 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"5.2 资源分配结构和策略 资源管理的实质是资源管理的机制和资源管理的策略。 机制：进行资源分配所必须的基本设施和部件，包括描述资源状态的数据结构、保证不可共享资源互斥使用的同步机构以及对不能立即得到满足的资源请求进行排队的各种资源队列的结构。 策略：资源分配的原则。 资源分配的机构 (1) 资源描述器 rd（resource descriptor） ① 资源描述器定义 描述描述各类资源的最小分配单位的数据结构称为资源描述器。 如：主存分区分配方法中，最小分配单位为主存分区。 ② 资源描述器内容：资源名、资源类型、最小分配单位的大小、地址、分配标志、描述器链接信息、存取权限、密级、存取时间 对于各类资源，若它具有N个资源分配器，则有N个资源描述器。描述器的组织方式取决于资源分配单位的数量和数量是否可变这一特征。 如表(数量不可变)、队列(数量可变)、数组(变化范围可知且不大) (2) 资源信息块 rib（resource information block）:描述某类资源的请求者、可用资源和该类资源分配程序的地址等必要信息的数据结构。 包括可利用资源队列、等待队列、资源分配程序入口地址 资源分配策略 对某类资源而言，在多个资源有多个请求者申请的情况下，资源分配的策略包括选择请求者的策略和选择资源的策略两种。 选择请求者的策略：即资源分配策略，即在众多请求者中选一个满足条件的请求者的原则。 选择资源的策略：是在同等资源间选择一个满足条件的资源的原则。 具体实现：体现在队列的排队原则上。 资源分配的时机 当请求者发出一个明确的资源请求命令时； 当处理机空闲时； 当一个存储区被释放变为空闲时； 当一个外存设备发生完成中断时。 (1) 常用的资源分配策略 ① 先请求先服务(FCFS) 每一个新产生的请求均排在队尾； 当资源可用时，取队首元素，并满足其需要。 ② 优先调度 对每一个进程指定一个优先级； 每一个新产生的请求，按其优先级的高低插到相应的位置； 当资源可用时，取队首元素，并满足其需要。 ③ 针对设备特性的调度策略 移臂调度：总是选取与当前移动臂前进方向上最近的那个I/O请求，使移臂距离最短。 旋转调度：总是选取与当前读写头最近的那个I/O请求，使旋转圈数最少。 ④ 几种移臂调度算法 最短寻道时间优先算法（SSTF） 从等待访问者中挑选寻找时间最短的那个请求先执行 缺点：可能会引起读写头在盘面上的大范围移动，可能会推迟请求的服务导致无限拖延 扫描算法（SCAN，即电梯调度算法） ​ 磁头前进方向上的最短查找时间优先算法 ​ 很大程度上消除了SSTF的不公平性 循环扫描算法（CSCAN） 规定磁头只做单向移动（单向电梯） ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"5.3 死锁 死锁定义：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待着别的进程释放它或它们现在保持着的资源，未改变这种状态之前都不能向前推进。此时，称这一组进程产生了死锁。 死锁的起因和必要条件 (1) 引起死锁的原因 ① 系统资源不足 ② 进程推进顺序非法 (2) 产生死锁的必要条件 ① 互斥条件 涉及的资源是非共享的，即为临界资源。 ② 不剥夺条件 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走。 ③ 部分分配 进程每次申请它所需要的一部分资源。在等待一新资源的同时，进程继续占用已分配到的资源。 ④ 环路条件 存在一种进程的循环链，链中的每一个进程已获得的资源同时被链中下一个进程所请求。 死锁处理方法 采用某种策略，限制并发进程对资源的请求，使系统在任何时刻都不满足死锁的必要条件。 (1) 死锁预防(Deadlock Prevention) 静态预防死锁的方法：在作业调度时为选中的作业分配它所需要的所有资源，当资源一旦分配给该作业后，在其整个运行期间这些资源为它独占。——资源利用率低 (2) 死锁避免(Deadlock Avoidance) 利用额外的先验信息，在分配资源时判断是否会出现死锁，只在不会死锁时分配资源 要求进程声明需要资源的最大数目 限定提供与分配的资源数量，确保满足进程的最大需求 动态检查资源分配状态，确保不会出现环形等待 动态避免死锁的方法： 有序资源分配法：系统中所有资源都给定一个唯一的编号，所有分配请求必须以上升的次序进行。当遵守上升次序的规则时，若资源可用，则予以分配；否则，请求者等待。(其缺点是资源浪费) 银行家算法：申请者事先说明对各类资源的最大需求量。在进程活动期间动态申请某类资源时，由系统审查现有该类资源的数目是否能满足当前进程的最大需求量，如能满足就予以分配，否则拒绝。(过于谨慎开销较大，但是按照银行家算法来分配资源是不会产生死锁的) (3) 死锁检测和恢复(Deadlock Detection \u0026 Recovery) 死锁检测：考察某一时刻系统状态是否合理(算法复杂，系统开销大) 在检测到运行系统进入死锁状态后，进行恢复，破坏循环等待(杀掉有关进程或删除文件，实际就是释放资源) ​ 由应用进程处理死锁 ​ 通常操作系统忽略死锁 系统状态分析 (1) 初始状态描述 假定一个系统包括n个进程和m类资源，表示如下 ① 一组确定的进程集合 p={p1，p2，…，pi，…，pn} ② 一组不同类型的资源集合 ​ r={r1，r2，…，rj，…，rm} ③ 矢量w说明各类可利用资源的总的数目 ​ w={w1，w2，…，wj，…，wm} (2) 资源请求矩阵 在时刻 t 资源请求矩阵，表示如下 dij 表示进程pi还需要j类资源的数目 (3) 资源分配矩阵 在时刻 t 资源分配矩阵，表示如下 aij 表示进程pi已占有j类资源的数目 系统是安全的：当进程请求某类资源时，进程对该类资源的需求量小于当前时刻系统所拥有的该类资源的数目，那么满足进程的这次请求，系统是安全的。 P个进程共享m个同类资源，每一个资源在任一时刻只能供一个进程使用，每一进程对任一资源都只能使用一有限时间，使用完便立即释放。并且每个进程对该类资源的最大需求量小于该类资源的数目。若所有进程对资源的最大需要数目之和小于p+m，则在该系统中不会发生死锁。 死锁的综合处理 根据资源特点选择最合适的方法 剥夺策略——处理机 静态资源分配——廉价资源、批处理系统 检测后处理 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第六章 处理机调度 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.2 处理机的多级调度 处理机调度的功能 确定数据结构 制定调度策略（调度原则） 给出调度算法 具体的实施处理机分派 批处理系统中 每个用户提交的算题任务，往往作为系统的一个处理单位，称为作业。 对处理机的分配分为两级： ​ 作业调度：对存放在辅存设备上的大量作业，以一定的策略进行挑选 ，分配主存等必要的资源，建立作业对应的进程，使其投 入运行。 ​ 进程调度：对进入主存的所有进程，确定哪个进程在什么时候获得处 理机，使用多长时间。 多任务操作系统中 系统将用户提交的任务处理为进程，进程作为动态资源分配和处理机的单位。 多线程操作系统中 处理机分配单位变为线程，系统提供线程调度程序。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.2 作业调度 作业的状态：后备、执行（包括就绪、运行、等待）、完成 主要任务：是完成作业从后备状态到执行状态和从执行状态到完成状态的转变。 作业调度的功能 确定数据结构：建立作业控制块(JCB,Job Control Block)，记录进入系统的作业情况(类型、状态、资源请求与分配等)； 确定调度策略与调度算法； 分配资源：为被选中的作业创建进程，并且为其申请系统资源； 善后处理：收回作业占用的全部资源，撤销作业控制块以及与该作业有关的全部进程。 作业控制块 每个作业进入系统时由系统为其建立一个作业控制块JCB(Job Control Block) 存放作业控制和管理信息 作业存在的标志 作业调度算法性能的衡量 通常采用平均周转时间和带权平均周转时间衡量作业调度算法性能的好坏。 (1) 周转时间：各作业提交给计算机系统到该作业的结果返回给用户所需要的时间。 (2) 带权周转时间：一个作业的周转时间与其运行时间的比值 说明作业i在系统中的相对等待时间，平均带权周转时间的精确度高于周转时间与平均周转时间 作业调度算法 先来先服务调度算法(FCFS) 短作业优先调度算法(运行时间最小) 响应比高者优先调度算法(响应比 = 响应时间 / 执行时间＝ 1 ＋ 等待时间 / 执行时间) 优先调度算法(综合各方面因素设置优先数) 均衡调度算法(一种更理想化的调度算法) ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.3 进程调度 调度/分派结构 处理机分配由调度和分派两个功能组成。 调度：组织和维护就绪进程队列，使排在首位的进程一定是满足调度原则的、可被选择的进程。包括确定调度算法、按调度算法组织和维护就绪进程队列。（按调度原则选择进程） 分派：处理机空闲时，从就绪队列队首中移一个PCB，并将该进程投入运行。 （赋予使用处理机的权限） 进程调度的功能 记录和保持系统中所有进程的有关情况和状态特征 决定分配策略 ​ 调度策略的不同，组织就绪进程队列的方式也不同。 先来先服务调度：就绪进程按等待时间大小的顺序排队 优先数调度：就绪进程按优先数的先后次序排队 实施处理机的分配和回收 进程调度的方式 (1) 非剥夺方式 当“重要而紧迫”的进程来到时，让正在执行的进程继续执行，直到该进程完成或发生某事件而进入“完成”或“阻塞”状态时，才把处理机分配给“重要而紧迫”的进程。 (2) 剥夺方式 当“重要而紧迫”的进程来到时，便暂停正在执行的进程，立即把处理机分配给优先级更高的进程。(增加处理机切换次数，开销更大，能及时响应紧急任务) 进程调度算法 (1) 进程优先数调度算法 ① 什么是进程优先数调度算法 按照某种原则由系统（或用户、或系统与用户结合）赋予每个进程一个优先数，系统把处理机的使用权赋予就绪队列中具备最高优先权 (优先数和一定的优先级相对应)的就绪进程。 ② 优先数的分类及确定 ⅰ 静态优先数：在进程被创建时确定，且一经确定后在整个进程运行期间不再改变。 ⅱ 静态优先数的确定 ​ 优先数根据进程所需使用的资源来计算 ​ 优先数基于程序运行时间的估计 ​ 优先数基于进程的类型 ⅲ 动态优先数：系统运行过程中，根据系统的设计目标，不断调整进程的优先数，其优点是能比较客观地反映进程的实际情况和保证达到系统设计目标。 ⅳ 动态优先数的确定 进程使用CPU超过一定数值时，降低优先数 进程I/O操作后，增加优先数 进程等待时间超过一定数值时，提高优先数 (2) 循环轮转调度算法 ① 什么是循环轮转调度算法 系统的响应时间分成大小相等（或不等）的时间片。当CPU空闲时，选取就绪队列首元素，赋予一个时间片，当时间片用完时，该进程转为就绪态并进入就绪队列末端。 ② 简单循环轮转调度算法 ​ 就绪队列中的所有进程以等速度向前进展。 ​ q = t/n ​ t 为用户所能接受的响应时间，n为进入系统的进程数目 ③ 循环轮转调度算法的发展 ​ 可变时间片轮转调度 ​ 多重时间片循环调度 (3) 多级反馈算法 ​ 多个简单算法的综合和发展，采用多个就绪队列结构，每个就绪队列的优先级按序递减，时间片长度按序递增。 调度用的进程状态变迁图 较简单的进程状态变迁图 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第七章 主存管理 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.1 主存管理概述 主存共享方式： 大小不等：分区存储管理/段式存储管理 大小相等：页式存储管理 二者结合：段页式存储管理 程序的逻辑地址 一维地址结构、二维地址结构（段+偏移量） ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.2 主存管理功能 几个概念 (1) 物理地址 (绝对地址、实地址) 物理地址是计算机主存单元的真实地址，又称为绝对地址或实地址。 (2) 主存空间 物理地址的集合所对应的空间组成了主存空间。 (3) 逻辑地址 (相对地址、虚地址) 用户的程序地址 (指令地址或操作数地址)均为逻辑地址。 (4) 程序地址空间 用户程序所有的逻辑地址集合对应的空间。 主存管理功能 地址映射、主存分配、存储保护、主存扩充 地址映射：将程序地址空间中使用的逻辑地址变换成主存中的物理地址的过程 时机\u0026类别 ① 编程或编译时确定地址映射关系 在程序编写或程序编译时确定虚、实地址之间的对应关系，结果是一个不能浮动的程序模块。 ② 在程序装入时确定地址映射关系 在程序装入过程中随即进行的地址变换方式称为静态地址映射。需软件(重定位装入程序) ③ 在程序运行时确定地址映射关系 在程序执行期间，随着每条指令和数据的访问自动地连续地进行地址映射，这种地址变换方式称为动态地址映射。需硬件地址变换机构(重定位寄存器) 主存分配 (1) 构造分配用的数据结构 主存资源信息块：等待队列；空闲区队列； (2) 制定策略 ① 分配策略 —— 在众多个请求者中选择一个请求者的原则 ② 放置策略 —— 在可用资源中，选择一个空闲区的原则 ③ 调入策略 —— 决定信息装入主存的时机 预调策略：预先将信息调入主存 请调策略：当需要信息时，将信息调入主存 ④ 淘汰策略 —— 在主存中没有可用的空闲区 (对某一程序而言)时，决定哪些信息从主存中移走，即确定淘汰已占用的内存区的原则。 (3) 实施主存分配与回收 存储保护 在多用户环境中，主存储器按区分配给各用户程序使用。为了互不影响，必须由硬件 (软件配合)保证各用户程序只能在给定的存储区域内活动，这种措施叫做存储保护。 上下界保护 ​ 基址、限长寄存器保护 主存扩充 (1) 可行性 局部性特征 (2) 实现方法 程序的全部代码和数据存放在辅存中； 将程序当前执行所涉及的那部分程序代码放入主存中； 程序执行时，当所需信息不在主存，由操作系统和硬件相 配合来完成主存从辅存中调入信息，程序继续执行。 (3) 虚拟存储器：由操作系统和硬件相配合来完成主存和辅存之间的信息的动态调度。这样的计算机系统好像为用户提供了一个其存储容量比实际主存大得多的存储器，这个存储器称为虚拟存储器。 虚拟存储器的核心 逻辑地址与物理地址分开 存储空间与虚地址空间分开 提供地址变换机构 实现虚拟存储器的物质基础 有相当容量的辅存： 足以存放应用程序的虚地址空间 ​ 有一定容量的主存： 存放进入主存的多进程的信息 ​ 地址变换机构 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.3 分区存储管理 允许多个程序共享内存空间，分为固定分区和可变分区 动态分区分配(可变分区) (1) 什么是动态分区分配 在处理程序的过程中，建立分区，依用户请求的大小分配分区。 分区长度不固定,分区个数不固定 (2) 分区分配需要的数据结构 ① 主存资源信息块 (M_RIB) ② 分区描述器 (PD) ③ 空闲区队列结构 分区的分配与回收 (1) 分区分配思路 ① 寻找空闲块 ​ 依申请者所要求的主存区的大小，分区分配程序在自由主存队列中找一个满足用户需要的空闲块； ② 若找到了所需的空闲区，有两种情况 ​ ⅰ 空闲区与要求的大小相等，将该空闲区分配并从队列中摘除； ​ ⅱ 空闲区大于所要求的的大小，将空闲区分为两部分：一部分成为已分配区，建立已分配区的描述器；剩下部分仍为空闲区。返回所分配区域的首址； ③ 否则，告之不能满足要求。 (2) 分区回收思路 ① 检查释放分区 (即为回收分区)在主存中的邻接情况若上、下邻接空闲区，则合并，成为一个连续的空闲区 ② 若回收分区不与任何空闲区相邻接建立一个新的空闲区，并加入到空闲区队列中。 放置策略：选择空闲区的策略，这改变的是空闲区队列的结构 **首次匹配 (首次适应算法)：**首次适应算法是将输入的程序放置到主存里第一个足够装入它的地址最低的空闲区中。 **最佳匹配 (最佳适应算法)：**最佳适应算法是将输入的程序放置到主存中与它所需大小最接近的空闲区中。 **最坏匹配 (最坏适应算法)：**最坏适应算法是将输入的程序放置到主存中与它所需大小差距最大的空闲区中。 碎片问题及拼接技术 碎片：在已分配区之间存在着的一些没有被充分利用的空闲区。 拼接技术：指移动存储器中某些已分配区中的信息，使本来分散的空闲区连成一个大的空闲区。（系统开销太大不能实现对主存的扩充） 对换技术：选择内存中的某个进程暂时移出到磁盘，腾出空间给其他进程，同时把磁盘中的某个进程换进主存使其投入运行 伙伴系统 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.4 页式存储管理 页式系统的基本概念 (1) 页面：程序的地址空间被等分成大小相等的片，称为页面，又称为虚页。 (2) 主存块：主存被等分成大小相等的片，称为主存块，又称为实页。 (3) 页表：为了实现从地址空间到物理主存的映象，系统建立的记录页与内存块之间对应关系的地址变换的机构称为页面映像表，简称页表。 ⅰ 高速缓冲存储器 ： 地址变换速度快，但成本较高 ⅱ 主存区域 ：地址变换速度比硬件慢，成本较低 页式地址变换 页号p+页内位移w 页式系统中用户地址空间： 一维地址空间 页的划分是信息的物理划分，页的大小是固定的，用户不可见，w字段的溢出自动加入到页号中 程序地址空间中，设100号单元处有如下指令：mov r1,[2500]。当这条指令执行时，如何进行正确的地址变换。 快表：在缓冲存储器（联想存储器）中存放正在运行的进程当前用到的页号和对应的块号，又称为快表。使用快表进行地址映射时，优先快表查询，未命中时再使用主存中的页表。 请调页面的机制 (1) 两种页式系统 ① 简单页式系统：装入一个程序的全部页面才能投入运行。 ② 请求页式系统： 装入一个程序的部分页面即可投入运行。 (2) 扩充页表功能 页表引入中断位与辅存地址 中断位i ： 标识该页是否在主存，若i=1，表示此页不在主存；若i=0，表示该页在主存 辅存地址 ：该页面在辅存的位置 访问不在主存中的页将发生缺页中断： 如分配给该程序的主存块中有空白块，则直接调入 如分配的无空白块，则需淘汰该程序在主存中的一页 4. 淘汰机制与策略 (1) 淘汰策略：用来选择淘汰哪一页的规则叫做置换策略，或称淘汰算法。 (2) 扩充页表功能——引入引用位与改变位 ① 引用位 —— 标识该页最近是否被访问 为“0”—— 该页没有被访问；为“1”—— 该页已被访问 ② 改变位 —— 表示该页是否被修改 为“0”—— 该页未被修改；为“1”—— 该页已被修改 (3) 颠簸：简单地说，导致系统效率急剧下降的主存和辅存之间的频繁页面置换现像称为“抖动”。 (4) 缺页中断率 假定程序p共有n页，系统分配m块，有 1≤m≤n； 若程序p在运行中：成功的访问次数为s，不成功的访问次数为f； 缺页中断率： f′=f/ (s+ f) f′= f (r，m，p)； r：置换算法；m：系统分配的块数； p：程序特征 (5) 常用的置换算法 ① 最佳算法(OPT算法) ：当要调入一新页而必须先淘汰一旧页时，所淘汰的那一页应是以后不再要用的，或者是在最长的时间以后才会用到的那页。 ② 先进先出淘汰算法(FIFO算法)：总是选择在主存中居留时间最长 (即最早进入主存)的一页淘汰（实现：建立进入主存的先后次序表，建立永远指向最早进入主存页面的替换指针） ③ 最久未使用淘汰算法(LRU算法)：总是选择最长时间未被使用的那一页淘汰。(硬件方法：采用计数器；软件方法：采用页号栈) ④ LRU近似淘汰算法：引入引用位，被访问后置1，系统周期性将所有引用位置0，淘汰时选择引用位为0的页 (6) 提高内存访问效率：快表、多级页表、反转页表 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.5 段页式存储管理 段式地址空间 (1) 什么是段：分段是程序中自然划分的一组逻辑意义完整的信息集合。 分段的例：代码分段、数据分段、栈段页。 (2) 程序地址空间 由若干个逻辑分段组成，每个分段有自己的名字，对于一个分段而言，它是一个连续的地址区。 段式地址变换 段式地址结构：段号s+段内位移w 段表：段号s+段长L+段首址b 取出程序地址(s，w)；用s检索段表；如w＜0或w≥L则主存越界；(b＋w)即为所需主存地址 段式系统中用户地址空间： 二维地址空间 段的划分是信息的逻辑划分，段长是可变的，用户可见，w字段的溢出将产生越界中断 段页式系统：在段内划分页面 段表：段号+页表长度+页表起始地址——\u003e页表：页号+其他+块号 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:5","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第八章 设备管理 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"8.1 设备管理概述 设备分类 (1) 存储设备：存储信息的设备，如：磁盘、磁鼓 (以块为单位传输信息) 。 (2) I/O设备：将信息从计算机外部输入到机内，或反之，如：键盘、显示器、打印机。 (3) 通信设备：负责计算机之间的信息传输，如调制解调器、网卡等。 计算机外部设备的特征：速度差异大、传输单位不同、容许的操作种类不同、出错条件不同 设备管理的目标 (1) 提高设备利用率 ① 合理分配设备 ② 提高设备与CPU、各外部设备之间的并行性 (2) 方便用户的使用 提供使用方便且独立于设备的界面 ① 统一：对各种不同的设备提供一致的界面 ② 独立于设备：用户使用的设备与物理设备无关 设备管理功能 (1) 状态跟踪 动态地记录各种设备的状态——设备控制块。 (2) 设备分配与回收 决定设备分配策略，实现设备分配、回收操作： ① 静态分配 —— 应用程序级 程序进入系统时进行分配，退出系统时收回全部资源。 ② 动态分配 —— 进程级 进程提出设备申请时进行分配，使用完毕后立即收回。 (3) 设备控制 实施设备驱动和中断处理的工作。 设备独立性 (1) 设备独立性概念 ① 什么是设备独立性 ​ 所谓设备独立性，是指用户在程序中使用的设备与实际使用的设备无关，也就是在用户程序中仅使用逻辑设备名。 ② 逻辑设备名 ​ 逻辑设备名，是用户自己指定的设备名 (或设备号)，它是暂时的、可更改的。 ③ 物理设备名 ​ 物理设备名，是系统提供的设备的标准名称，它是永久的、不可更改的。 (2) 两种类型的设备独立性 ① 一个程序独立于分配给它的某种类型的具体设备 ​ 系统可以根据设备的使用情况，动态地分配给程序某类设备中的任一台物理设备，程序都能正确地执行。 ② 程序应尽可能与它所使用的I/O设备类型无关 ​ 在输入 (或输出)信息时，信息可以从不同类型的输入 (或输出)设备上输入 (或输出)，若要改变输入 (或输出) 设备的类型，程序只需进行最少的修改。 (3) 设备独立性的实现 ① 在高级语言中用软通道实现 ​ 使用高级语言提供的指派语句，通过指派一个逻辑设备名(通道号)来定义一个设备或文件。 如：fd = open(“/dev/lp” ,mode) 使fd与设备相连 ② 在批处理系统中，用联接说明语句来定义 ​ 如：OUTPUT1 = LPT ③ 在交互系统中，用指派命令来定义 ​ 如：PDP系列机上的RT11系统 ​ ASSIGN \u003c设备物理名\u003e \u003c设备逻辑名\u003e 一次对一个设备赋名 ④ 逻辑设备描述器ldd：描述逻辑设备名和物理设备名的关系，包含设备逻辑名、设备物理名、设备控制块(DCB)指针、逻辑设备描述器队列勾链字。 设备控制块DCB：系统为每一台设备都配置了一个用来记录设备的硬件特性、连接和使用情况的一组数据，称为设备控制块。包括设备名、设备属性、命令转换表等。 (4) 设备独立性的优点 方便用户 改善设备利用率 提高系统的可扩展性和可适应性 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"8.2 缓冲技术 缓冲概念 (1) 什么是缓冲 缓冲是两种不同速度的设备之间传输信息时平滑传输过程的常用手段。 (2) 缓冲类别 ① 缓冲器 缓冲器是用来暂时存放数据的一种存储装置，它容量较小，存取速度快。 ② 软件缓冲 在I/O操作期间用来临时存放I/O数据的一块存储区域。 (3) 为什么要引入缓冲 ​① 处理数据流的生产者与消费者间的速度差异 ​ 如：从调制解调器收到一个文件，并保存到硬盘上。 ② 协调传输数据大小不一致的设备 ​ 如：在计算机网络中用来处理消息的分段和重组。 ③ 应用程序的拷贝语义 ​如：操作系统为保证系统调用write的正确语义(在调用write到系统调用返回时，缓冲区的内容可能改变引发不一致，需要将应用程序缓冲区复制到内核缓冲区) 常用的缓冲技术 (1) 双缓冲 在双缓冲方案下，为输入或输出分配两个缓冲区buf1 、buf2 。 (2) 环形缓冲 在系统中设置若干个缓冲区，并把这些缓冲区链接起来，这样若干个缓冲区就形成了一个环，故称环形缓冲区。 (3) 缓冲池 系统设置多个缓冲区，形成一个缓冲池。这个池中的缓冲区为系统中所有的进程共享使用。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"8.3 设备分配 静态分配 当一个作业运行时，系统如果能满足作业要求的设备，则将其要求的设备全部分配给它，然后开始运行，运行完成释放其占用的所有设备。 优点：系统绝不会出现死锁， 缺点是设备利用率太低。 动态分配 在作业（或进程）运行的过程中，需要使用设备时，就向系统申请，系统根据某种分 配原则进行分配。 优点：设备的利用率高， 缺点是系统有出现死锁的可能。 设备分配算法 先来先服务算法、优先级高者优先 设备分配的安全性 对于共享设备，不论采用静态分配还是采用动态分配都不会出现死锁 对于独占设备，采用动态分配有可能造成死锁 独享分配 (1) 独享设备 ① 让一个作业在整个运行期间独占使用的设备 ② 特点 ⅰ 临界资源 ⅱ 费时的I/O操作或需人工干预 (2) 独享分配 考虑安全策略： 静态分配方式：简单、不发生死锁、但利用率不高 动态分配方式：不安全 共享分配 (1) 共享设备 ① 由多个作业、进程共同使用的设备称为共享设备。 ② 特点 ⅰ 旋转设备，可直接或随机访问 ⅱ 便于共享，转接简单，耗费较少 (2) 共享分配 考虑调度性能 虚拟分配 有限的独占设备，低速的独占设备，严重影响整个计算机系统效率——在高速共享设备上能否模拟低速设备的功能 (1) 虚拟技术 所谓虚拟技术，是在一类物理设备上模拟另一类物理设备的技术，是将独占设备转化为共享设备的技术。思想是利用系统中的便于共享的、快速的存储设备来替代不适合共享的、慢速的字符设备，采用预先收存、延迟发送的方式来改造独占设备。 (2) 虚拟设备 通常把用来代替独占型设备的那部分外存空间 (包括有关的控制表格)称为虚拟设备。 (3) 虚拟分配 当进程需要与独占型设备交换信息时，系统将分配磁盘空间，并建立相应的数据结构，这种分配方法称为设备的虚拟分配。 假脱机系统Spool 提供外围设备同时联机操作的功能 (1) 设计思想 ① 预输入 在应用程序需要数据前，OS已将所需数据预先输入到辅存输入井存放。当应用程序 (或进程) 需要数据时，可直接从辅存中读入主存。 ② 缓输出 在应用程序执行时，将输出数据写入辅存输出井中。当应用程序 (或进程)执行完毕 (或需要数据时) ，由操作系统将数据输出。 (2) 什么是SPOOLING系统 ​ 利用通道和中断技术，在主机控制之下，由通道完成输入输出工作。系统提供一个软件系统 (包括预输入程序、缓输出程序、井管理程序、预输入表、缓输出表)。它提供输入收存和输出发送的功能，使外部设备可以并行操作。这一软件系统称为SPOOLING系统。 (3) SPOOLING系统的优点 ① 提供虚拟设备 ② 外围设备同时联机操作 ③ 加快作业处理速度 (4) 实现SPOOLING系统的基础 ① 大容量的辅存空间 在辅存上需开辟两个较大的输入井和输出井，用以存放大量应用程序的输入信息和输出信息。 ② 硬件基础 通道装置、中断系统 ③ 数据结构 预输入表、缓输出表：描述辅存输入井和输出井的状态变化。 如： 输入信息从哪台设备输入，存放在辅存输入井什么位置；输出信息存放在辅存输出井什么位置，从哪台输出设备输出。 ④ 所需的软件程序 ⅰ 预输入程序 控制信息从独占设备输入到辅存 ⅱ 缓输出程序 控制信息从辅存输出到独占设备 ⅲ 井管理程序 控制用户程序和辅存之间的信息交换 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"8.4 设备分配 输入/输出控制方式 CPU通过I/O控制器与物理设备打交道。按照I/O控制器智能化程度的高低，将I/O设备的控制方式分为四类： 循环测试I/O方式、I/O中断方式、DMA方式、通道方式 I/O子系统 (1) 图示 (2) I/O子系统的特点 ① 在应用层为用户提供 I/O应用接口 对设备的控制和操作则由内核I/O子系统来实施。 ② 每个通用设备类型都通过一组标准函数 (及接口)来访问 具体的差别被I/O子系统中的内核模块(称为设备驱动程序)所封装，这些设备驱动程序一方面可以定制以适合各种设备，另一方面也提供了一组标准的接口。 设备驱动程序层的作用是为内核I/O子系统隐藏设备控制器之间的差异。将I/O子系统与硬件分离，简化了操作系统开发人员的任务，也有利于设备的设计与制造。 (3) I/O控制的功能 ① 解释用户的I/O系统调用 ② 设备驱动 ③ 中断处理 (4) 设备处理程序 设备处理程序是能直接控制设备运转的程序，它根据各类设备的特点和性能来编写。每一类设备有一个相应的设备处理程序，能控制同类中多台物理设备同时工作。 (5) 控制I/O核心模块的方式 ① 以设备处理进程的方式 ⅰ 为每一类设备设置一个设备处理进程 (对应的程序就是设备处理程序)； ⅱ 当有I/O请求来到时该进程被唤醒，进行设备驱动工作；当没有I/O请求时，该进程睡眠。 由I/O控制模块的接口程序负责解释用户的I/O系统调用，将其转换成I/O控制模块认识的命令形式后，将I/O请求发给对应的设备处理进程。 ② 将设备与文件一样对待 将设备与文件一样对待，使用文件系统的系统调用命令进行设备的读、写。 输入/输出控制的例子 (1) 用户进程请求I/O的系统功能调用 系统功能调用的形式为： doio(ldev,mode,amount,addr); ldev： 逻辑设备名 mode： 操作模式 amount：传输数据的数目 addr： 传送地址 (2) I/O接口程序 (I/O过程) ① 将逻辑设备转换为物理设备 ⅰ 获得 I/O系统调用中给出的逻辑设备名 (ldev)； ⅱ 根据逻辑设备描述器，将逻辑设备名转换为物理设备名。 ② 合法性检查 ⅰ 获得 I/O系统调用中给出的操作模式mode； ⅱ 根据DCB中命令转换表中允许的操作，检查操作的合法性。 ③ 形成I/O请求块，发消息给对应的设备处理进程 ⅰ 根据请求的参数形成I/O请求块 (IORB)； ⅱ 将I/O请求块 (IORB)挂到对应的设备请求队列。 (3) 设备处理进程 process io { l： while (设备请求队列不空){ 取一个iorb； 提取请求的详细信息； 启动I/O操作； sleep (事件：I/O完成) / * I/O操作 * / / * 等I/O完成后，进入中断处理程序，并在那里唤醒设备处理进程 * / if (出错) 将错误信息写在该设备的dcb中； 传送数据到目的地； 唤醒请求此I/O操作的进程； 删除iorb； } sleep (事件：因无I/O请求)； goto l ； } (4) 请求I/O的进程、I/O过程、设备处理进程、中断处理程序之间的同步关系 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:8:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第九章 文件系统 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:0","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.1 文件系统概述 文件 定义：在逻辑上具有完整意义的信息集合，它有一个名字以供标识，文件名是以字母开头的字母数字串。 构成文件的基本单位：可以是信息项，也可以是记录 文件其他描述： ① 文件是具有符号名的信息(数据)项的集合； ② 文件是具有符号名的记录的集合 文件分类 ① 按文件的性质和用途分类 系统文件 程序库文件 用户文件 ② 按文件保护级别分类 不保护文件 执行文件 只读文件 读写文件 ③ 分类按文件流向分类 输入文件 输出文件 输入输出文件 文件名与属性 ① 文件名：每个文件有一个给定的名字，这个名字是由串描述且由文件内容来表示，包括文件符号名和内部标识符。用户使用文件符号名进行文件操作，系统使用文件内部标识符管理文件。 ② 文件扩展：文件扩展表示文件的使用特征，如：.c .obj .lib 等。 ③ 文件属性：文件的属性字，表示文件类别、保护级等信息。 文件系统：操作系统中负责管理和存取文件信息的软件机构。 文件系统的组成 ① 管理文件所需的数据结构(如目录表、文件控制块、存储分配表) ② 管理程序 ③ 一组操作 文件系统的功能 ① 从用户角度看 —— 文件系统实现了“按名存取”的功能。 ② 从系统角度看 —— 辅存空间管理(文件块、空闲块、分配算法) 文件集合管理（构造文件结构、文件存取、文件共享和访问） 文件保护（数据可靠和安全） 文件系统的特点 ① 使用简单 使用文件名、一组文件操作命令。 ② 安全可靠提供防护措施，在文件遭受破坏时，能及时复全量备份、增量备份、动态备份、远程备份 ③ 既能共享，又能保密 身份验证、存取权限验证 文件组织的两种结构 (1) 文件的逻辑结构 ① 逻辑文件：从用户角度看到的文件面貌。即用户对信息进行逻辑组织形成的文件结构。② 研究文件逻辑结构的目的 ⅰ 为用户提供一种逻辑结构清晰、使用简便的逻辑文件形式。 ⅱ 用户按文件的逻辑结构形式去存储、检索和加工文件中的信息。 (2) 文件的物理结构 ① 物理文件：文件的物理结构是信息在物理存储器上的存储方式，是数据的物理表示和组织。 ② 研究文件物理结构的目的 ⅰ 选择工作性能良好、设备利用率高的物理文件形式。 ⅱ 系统按照文件的物理结构形式和外部设备打交道，控制信息的传输。 (3) 逻辑记录与物理记录 (磁盘块) ① 逻辑记录 文件中按信息在逻辑上的独立含义来划分的信息单位，逻辑记录是对文件进行存取操作的基本单位。 ② 物理记录 在存储介质上，由连续信息所组成的一个区域称为块，也叫物理记录。 ③ 逻辑记录与物理记录的区别与联系 ⅰ 一个是逻辑的概念，一个是物理的概念。 ⅱ 逻辑记录最终要存放到物理记录上。 iii 逻辑记录大小不一定等于物理记录大小。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:1","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.2 文件的逻辑结构与存取方法 文件的逻辑结构 (1) 流式文件 ① 什么是流式文件 流式文件是相关的有序字符的集合，是无结构的。 ② 流式文件的存取 流式文件是按信息的个数或以特殊字符为界进行存取的。 (2) 记录式文件 ① 什么是记录式文件 记录式文件是一种有结构的文件。这种文件在逻辑上总是被看成一组连续顺序的记录的集合。 ② 记录式文件分为定长记录和变长记录 文件存取方法 (1) 顺序存取（磁带文件） 后一次存取总是在前一次存取的基础上进行的。 顺序存取时不必给出具体的存取位置。 (2) 随机存取（磁盘、磁带上的文件） 用户以任意次序请求某个记录。 随机存取时要指出起始存取位置 (例如记录号)。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:2","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.3 文件的物理结构 常用的文件物理结构：连续文件、串联文件、索引结构 连续文件 (1) 什么是连续文件 ​连续文件结构是由一组分配在磁盘连续区域的物理块组成的。 (2) 连续文件的特点 ​① 结构简单，实现容易，连续存取时速度较快 ​② 创建文件时要给出文件大小，文件长度一经固定便不易改变，动态增加和修改不易 ​③ 存储空间利用率不高（碎片） 2. 串联文件 (1) 什么是串联文件 串联文件结构是按顺序由串联的块组成的，即文件的信息存于若干块物理块中，每个物理块的最末一个字作为链接字，它指出后继块的物理地址。文件的最后一块的链接字为结束标记“^”，它表示文件至本块结束。 (2) 串联文件的特点 ① 能较好地利用辅存空间，提高利用率 ② 不必事先知道文件长度，易于对文件进行修改和扩充 ③ 连续存取时速度较快，随机存取效率太低 ④ 链接指针占用一定空间 ⑤可靠性问题，指针容易出错 (3) 文件映照技术：把链接指针按顺序集中存放，构成盘文件映射表/文件分配表(FAT) 3. 索引文件 (1) 什么是索引文件 系统为每个文件建立逻辑块号与物理块号的对照表。这张表称为该文件的索引表。文件由数据文件和索引表构成。这种文件称为索引文件。 (2) 索引文件的操作 ① 索引文件在存储区中占两个区 ⅰ 索引区：存放索引表 ⅱ 数据区：存放数据文件 ② 访问索引文件的操作 ⅰ 查文件索引，由逻辑块号查得物理块号 ⅱ 由此磁盘物理块号而获得所要求的信息 (3) 索引文件的特点 ① 易于文件的增删 ② 直接读写任意记录 ③ 没有碎片 ④ 索引表带来的开销 (4) 多级索引 直接索引：文件目录项中有一组表项用于索引。每一个表项登记的是逻辑记录所在的磁盘块号。 一级间接索引：文件目录项中有一组表项，其内容登记的是第一级索引表块的块号。第一级索引表块中的索引表项登记的是文件逻辑记录所在的磁盘块号。 二级间接索引：文件目录项中有一组表项，其内容登记的是第二级索引表块的块号。第二级索引表块中的索引表项登记的第一级索引表块的块号，第一级索引表项中登记的是文件逻辑记录所在的磁盘块号。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:3","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.4 文件存储空间的管理 几种文件存储空间管理的方法： ​ 空白文件(空闲文件目录) ​ 为所有空闲文件单独建立一个目录 ​ 空闲块链 ​ 把所有空闲块链在一起 ​ 位示图 ​ 通过位示图反映整个存储空间的分配情况 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:4","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.5 文件目录及其结构 文件目录有关概念 (1) 文件目录：文件目录是记录文件的名字、存放地址及其他有关文件的说明信息和控制信息的数据结构。 (2) 文件目录项的内容 ① 文件名 ② 文件逻辑结构：说明该文件的记录是否定长、记录长度及记录个数等 ③ 文件物理结构：记录文件的物理结构形式 ​ 连续文件——指出文件第一块的物理地址、文件所占块数 ​ 串联文件——指出该文件第一块的物理地址 ​ 索引文件——指出索引表地址 ④ 存取控制信息 ​ 文件主具有的存取权限、核准的其他用户及其相应的存取权限 ⑤ 管理信息 ​ 文件建立日期、时间，上一次存取时间、要求文件保留的时间等 ⑥ 文件类型 ​ 文件的类型，例如可分为数据文件、目录文件、块存储设备文件、字符设备文件 一级文件目录 (1) 一级文件目录：系统将已建立的所有文件的文件名、存放地址及有关的说明信息放在一张表中，这张表称为一级文件目录。 (2) 一级文件目录的特点 ​ 实现了按名存取的功能，比较简单； ​ 文件多时，目录检索时间长 ​ 要求文件名和文件之间有一一对应的关系，即：不允许两个文件有相同的名字。(多用户环境中有命名冲突，即指不同用户对不同文件起了相同的名字，即两个或多个文件只有一个相同的符号名。又称为重名问题。) 树型文件目录 (1) 什么是树型文件目录 ​ 在多级目录系统中 (除最末一级外)，任何一级目录的目录项可以描述一个目录文件，也可以描述一个非目录文件 (数据文件)，而数据文件一定在树叶上。这样，就构成了一个树形层次结构。 (2) 文件路径名：多级目录中，文件的路径名是由根目录到该文件的通路上所有目录文件符号名和该文件的符号名组成的字符串，相互之间用分隔符分隔。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:5","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.6 文件共享与安全 (1) 文件共享：文件共享是指某一个或某一部分文件可以让事先规定的某些用户共同使用 共享的目的：节省存储空间、进程间交换信息 (2) 文件安全 ① 文件安全：所谓文件安全，就是文件的保护问题。文件的保护是指文件本身不得被未经文件主授权的任何用户存取，而对于授权用户也只能在允许的存取权限内使用文件。 ② 如何进文件的保护 ​ 需要对用户的权限进行验证。所谓存取权限的验证，是指用户存取文件之前，需要检查用户的存取权限是否符合规定，符合者允许使用，否则拒绝。 ③ 验证用户存取权限的方法 ​ ⅰ 访问控制矩阵 ​ ⅱ 存取控制表 ​ ⅲ 用户权限表 ​ ⅳ 口令 ​ ⅴ 密码（编解码） (3) 用文件路径名加快文件的查找 ① 当前目录：当前用户正在使用的文件所在的目录。当指定当前目录后，用户对文件的所有访问都是相对于 “当前目录”进行的。这时，文件路径名是由“当前目录”到信息文件的通路上所有各级目录的符号名加上该信息文件的符号名组成。 ② 链接技术：所谓“链接”，就是在相应目录表目之间进行链接，即一个目录中的表目直接指向另一个目录表目所在的物理位置。注意，这种链接不是直接指向文件，而是指向相应的目 录表目。这种办法也称为连访，被共享的文件称为连访文件。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:6","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.7 文件操作与文件备份 文件操作 (1) 常用的文件操作命令 create 创建一个新文件 delete 从系统目录中撤消一个文件 rename 在系统目录中改变文件的名字 open 打开文件 在用户和文件(或设备)之间建立一个逻辑通路 close 关闭文件 在用户和文件(或设备)之间撤消一个逻辑通路 write 写到一个文件(或设备)上 read 从一个文件(或设备)读入数据信息 (2) “打开文件”和“关闭文件”操作操作 ① 打开文件操作 ​ 所谓打开文件就是把该文件的有关目录表目复制到主存中约定的区域，建立文件控制块，建立用户和这个文件的联系。 ② 关闭文件操作 ​ 所谓关闭文件就是用户宣布这个文件当前不再使用，系统将其在主存中的文件控制块删去，因而也就切断了用户同这个文件的联系。 文件备份 (1) 什么是文件备份 ​ 为了能在软、硬件失效的意外情况下恢复文件，保证文件的完整性、数据的连续可利用性，文件系统提供适当的机构，以便复制备份。 (2) 文件备份的方法 ① 周期性转储 ​ 按固定的时间周期把存储器中所有文件的内容转存到某种介质上，通常是磁带或磁盘。在系统失效时，使用这些转存磁盘或磁带，将所有文件重新建立并恢复到最后一次转存时的状态。 ② 增量性转储 ​ 这种技术转储的只是从上次转储以后已经改变过的信息；增量转储的信息量较小，故转储可在更短的时间周期内进行。 (3) 文件备份的发展 ① 动态备份 ② 远程备份技术 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:7","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.8 UNIX文件系统 UNIX文件的特点 ① 树型文件目录结构 ② 可安装拆卸的文件系统 ③ 文件是无结构的字符流式文件 ④ 将外部设备与文件一样对待 UNIX文件的类型 ① 普通文件 用户程序、数据文件 ② 目录文件 用于组织和形成树型目录结构中的一个单位，由若干目录项组成。 ③ 特别文件 与硬设备有关的文件称为特别文件。 ​ 空白文件(空闲文件目录) ​ 为所有空闲文件单独建立一个目录 ​ 空闲块链 ​ 把所有空闲块链在一起 ​ 位示图 ​ 通过位示图反映整个存储空间的分配情况 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:8","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.5 文件目录及其结构 文件目录有关概念 (1) 文件目录：文件目录是记录文件的名字、存放地址及其他有关文件的说明信息和控制信息的数据结构。 (2) 文件目录项的内容 ① 文件名 ② 文件逻辑结构：说明该文件的记录是否定长、记录长度及记录个数等 ③ 文件物理结构：记录文件的物理结构形式 ​ 连续文件——指出文件第一块的物理地址、文件所占块数 ​ 串联文件——指出该文件第一块的物理地址 ​ 索引文件——指出索引表地址 ④ 存取控制信息 ​ 文件主具有的存取权限、核准的其他用户及其相应的存取权限 ⑤ 管理信息 ​ 文件建立日期、时间，上一次存取时间、要求文件保留的时间等 ⑥ 文件类型 ​ 文件的类型，例如可分为数据文件、目录文件、块存储设备文件、字符设备文件 一级文件目录 (1) 一级文件目录：系统将已建立的所有文件的文件名、存放地址及有关的说明信息放在一张表中，这张表称为一级文件目录。 (2) 一级文件目录的特点 ​ 实现了按名存取的功能，比较简单； ​ 文件多时，目录检索时间长 ​ 要求文件名和文件之间有一一对应的关系，即：不允许两个文件有相同的名字。(多用户环境中有命名冲突，即指不同用户对不同文件起了相同的名字，即两个或多个文件只有一个相同的符号名。又称为重名问题。) 树型文件目录 (1) 什么是树型文件目录 ​ 在多级目录系统中 (除最末一级外)，任何一级目录的目录项可以描述一个目录文件，也可以描述一个非目录文件 (数据文件)，而数据文件一定在树叶上。这样，就构成了一个树形层次结构。 (2) 文件路径名：多级目录中，文件的路径名是由根目录到该文件的通路上所有目录文件符号名和该文件的符号名组成的字符串，相互之间用分隔符分隔。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:9","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.6 文件共享与安全 (1) 文件共享：文件共享是指某一个或某一部分文件可以让事先规定的某些用户共同使用 共享的目的：节省存储空间、进程间交换信息 (2) 文件安全 ① 文件安全：所谓文件安全，就是文件的保护问题。文件的保护是指文件本身不得被未经文件主授权的任何用户存取，而对于授权用户也只能在允许的存取权限内使用文件。 ② 如何进文件的保护 ​ 需要对用户的权限进行验证。所谓存取权限的验证，是指用户存取文件之前，需要检查用户的存取权限是否符合规定，符合者允许使用，否则拒绝。 ③ 验证用户存取权限的方法 ​ ⅰ 访问控制矩阵 ​ ⅱ 存取控制表 ​ ⅲ 用户权限表 ​ ⅳ 口令 ​ ⅴ 密码（编解码） (3) 用文件路径名加快文件的查找 ① 当前目录：当前用户正在使用的文件所在的目录。当指定当前目录后，用户对文件的所有访问都是相对于 “当前目录”进行的。这时，文件路径名是由“当前目录”到信息文件的通路上所有各级目录的符号名加上该信息文件的符号名组成。 ② 链接技术：所谓“链接”，就是在相应目录表目之间进行链接，即一个目录中的表目直接指向另一个目录表目所在的物理位置。注意，这种链接不是直接指向文件，而是指向相应的目 录表目。这种办法也称为连访，被共享的文件称为连访文件。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:10","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.7 文件操作与文件备份 文件操作 (1) 常用的文件操作命令 create 创建一个新文件 delete 从系统目录中撤消一个文件 rename 在系统目录中改变文件的名字 open 打开文件 在用户和文件(或设备)之间建立一个逻辑通路 close 关闭文件 在用户和文件(或设备)之间撤消一个逻辑通路 write 写到一个文件(或设备)上 read 从一个文件(或设备)读入数据信息 (2) “打开文件”和“关闭文件”操作操作 ① 打开文件操作 ​ 所谓打开文件就是把该文件的有关目录表目复制到主存中约定的区域，建立文件控制块，建立用户和这个文件的联系。 ② 关闭文件操作 ​ 所谓关闭文件就是用户宣布这个文件当前不再使用，系统将其在主存中的文件控制块删去，因而也就切断了用户同这个文件的联系。 文件备份 (1) 什么是文件备份 ​ 为了能在软、硬件失效的意外情况下恢复文件，保证文件的完整性、数据的连续可利用性，文件系统提供适当的机构，以便复制备份。 (2) 文件备份的方法 ① 周期性转储 ​ 按固定的时间周期把存储器中所有文件的内容转存到某种介质上，通常是磁带或磁盘。在系统失效时，使用这些转存磁盘或磁带，将所有文件重新建立并恢复到最后一次转存时的状态。 ② 增量性转储 ​ 这种技术转储的只是从上次转储以后已经改变过的信息；增量转储的信息量较小，故转储可在更短的时间周期内进行。 (3) 文件备份的发展 ① 动态备份 ② 远程备份技术 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:11","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"9.8 UNIX文件系统 UNIX文件的特点 ① 树型文件目录结构 ② 可安装拆卸的文件系统 ③ 文件是无结构的字符流式文件 ④ 将外部设备与文件一样对待 UNIX文件的类型 ① 普通文件 用户程序、数据文件 ② 目录文件 用于组织和形成树型目录结构中的一个单位，由若干目录项组成。 ③ 特别文件 与硬设备有关的文件称为特别文件。 包括块设备文件、字符设备文件。与计算机连接每一种输入输出设备都有一个特别文件。它是操作系统核心用于存取输入输出设备的通道，是用户与硬件设备联系的桥梁。 ","date":"2021-02-03","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:9:12","tags":["操作系统原理"],"title":"计算机操作系统原理复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"计算机网络复习笔记 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:0:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第一章 计算机网络和因特网 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.1 什么是因特网——因特网的具体构成 两种方式回答： 1.描述因特网的具体构成(具体硬件和软件组件) 2.根据为分布式应用提供服务的联网基础设施来描述 组成描述 用因特网的术语来说，所有连入因特网的设备都叫做主机或者端系统 连接在因特网上的数十亿计的互连计算机设备: 主机 = 端系统 运行网络应用程序 连接因特网上各种设备的通信链路 光纤，铜缆，无线电，人造卫星 传输速率 = 带宽 转发分组(数据块)的分组交换机 链路层交换机 路由器 因特网服务提供商ISP ：端系统通过ISP接入因特网，ISP也彼此互联 因特网协议:控制因特网中信息的接受和发送，因特网协议统称为TCP/IP 因特网标准：定义协议，实现各个协议及其作用取得一致作用，IETF研发，其标准文档称为RFC 服务描述 向应用程序提供服务的基础设施(分布式应用程序) 网页浏览、VoIP、电子邮件、 游戏、电子商务、社交网络、… NC、云 向应用程序提供编程接口(套接字接口) 允许应用程序连接到因特网上的钩子 提供不同级别的服务可选项：类似于邮政服务 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.2 网络边缘 网络边缘:端系统(桌面计算机、服务器、移动计算机、越来越多的非传统物品) 网络应用服务模型：C/S、P2P 接入网：将网络边缘与网络核心(通常是边缘路由器)连接起来 边缘路由器：端系统到任何其它远程端系统的路径上的第一台路由器 接入的方式 ​ 家庭：Modem拨号/ADSL拨号/HFC/FTTH/卫星 ​ 机构：以太网/Wi-Fi ​ 广域无线接入：3G/4G/5G/LTE 物理媒体 ​ 引导性媒体(信号沿固体媒体被引导):双绞线 ​ 非引导性媒体(自由传播):同轴电缆、光缆、无线电 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.3 网络核心 第一代计算机网络——电路交换网络 数据交换过程 ​ 第一步：建立连接 ​ 第二步：交换数据 ​ 第三步：释放连接 电路交换的特性 ​ 数据交换前需建立起一条从发端到收端的物理通路 ​ 在数据交换的全部时间内用户始终占用端到端的固定传输信道 ​ 交换双方可实时进行数据交换而不会存在任何延迟 电路交换中的复用（分类） ​ 时分复用 ​ 频分复用 存在的问题 ​ 计算机之间的数据交换往往具有突发性和间歇性特征，而对电路交换而言，用户支付的费用则是按用户占用线路的时间来收费的 ​ 不够灵活。只要在通话双方建立的通路中的任何一点出了故障，就必须重新拨号建立新的连接，这对紧急和重要通信是很不利的。 第二代计算机网络——分组交换网络 分组交换的工作流程 在发送端，先把较长的报文划分成较短的、固定长度的数据段 每一个数据段前面添加上首部构成分组 分组交换网以“分组”作为数据传输单元 依次把各分组发送到接收端 接收端收到分组后剥去首部还原成报文 最后，在接收端把收到的数据恢复成为原来的报文 分组交换网络分类 ​ 虚电路网络 ​ 数据报网络 ISP与因特网主干 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:3","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.4 分组交换网络中的时延、丢包和吞吐量 时延类型: 节点处理时延 ​ dproc: 节点处理 ​ 检查比特错误 ​ 确定输出链路 ​ 通常\u003c毫秒 排队时延 ​ 输出链路等待传输的时间 ​ 取决于路由器的拥塞程度 传输时延:将所有分组比特推向链路的时间 ​ L:分组长度 (bits) ​ R:链路带宽 (bps) $$ d_{trans}=L/R $$ 传播时延:一个比特从一台路由器到另一个路由器的时间 ​ d:物理链路的长度 ​ s:媒体中的传播速度 (~2x108 米/秒) $$ d_{prop}=d/s $$ **排队时延** 假定 ​ R=链路带宽 (bps) ​ L=分组长度 (bits) ​ a=平均分组到达速率 流量强度：La/R ​ La/R ~ 0: 平均排队时延很小，甚至为0 ​ La/R \u003c 1: 时延较小，且会随时间推延而变小 ​ La/R = 1: 时延不会变化，具体数值取决于当时队列长度 ​ La/R \u003e 1: 平均时延较大，且随时间推延而趋于无穷! 端到端时延: ​ $$ d_{end-end}=N(d_{proc}+d_{trans}+d_{prop}) $$ 丢包 分组丢失的原因和后果 ​ 缓存中队列的容量是有限的 ​ 当分组到达时队列已满，则分组被丢弃 (丢失) ​ 丢失的分组可能会被前一个节点、源端系统重新传输，或者根本不重传 吞吐量：在发送方与接收方之间传输比特的速率（bps） ​ 瞬时吞吐量 ​ 平均吞吐量（一个连接的由最小吞吐量的链路决定，这条链路也称为瓶颈链路） ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:4","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"1.5 协议层次及其服务模型 因特网的协议栈 ​ 应用层: 支持网络应用 ​ FTP, SMTP, HTTP ​ 运输层: 主机间的数据传输 ​ TCP, UDP ​ 网络层:将数据报从源端传送到目的端 ​ IP, 路由协议 ​ 链路层: 数据在网络相邻结点之间传输 ​ PPP, 以太网 ​ 物理层: 在线路上传输比特流 ​ (应 运 网 链 物) ISO/OSI参考模型 ​ 表示层: 允许应用程序解释数据的含义，如：加密、压缩、特定机器的数据描述方法 ​ 会话层: 提供了数据交换的同步、定界、建立检查点和恢复的能力 ​ (应 表 会 运 网 链 物) 基本概念 实体(Entity) ​ 实体是任何可以发送和接收信息的硬件和软件进程。通常是一个特定的软件模块 对等体(Peer) ​ 不同机器上包含对应层的实体称为对等体 协议(Protocol) ​ 语法，即数据与控制信息的结构或格式 ​ 语义，即需发现何种控制信息，完成何种动作以及做出何种应答 ​ 同步，即事件实现顺序的详细说明 服务(Service) ​ 为保证上层对等体之间能互相通信，下层向上层提供的功能。 服务原语 ​ 服务原语是指网络相邻层间进行交互时所要交换的一些必要命令 服务访问点(SAP) ​ 服务访问点是同一系统中相邻两层的实体进行交互的地方 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:1:5","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第二章 应用层 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"2.1 应用层协议原理 网络应用 网络应用所需采用的体系结构 ​ 客户机/服务器体系结构（C/S）:存在一个能够向客户机提供服务的服务器，存在一个或者多个主动连接服务器，试图从服务器那里获取所需服务的客户机 ​ 特别注意1：客户机之间不能互相通信 ​ 特别注意2：为提高服务器的处理能力，通常采用服务器群集（Server Farm） ​ P2P体系结构:任何一方既提供服务又享受服务,结点之间可以直接通信,结点的地址以及他们之间的连接可能随时发生变化 ​ 特别注意：P2P体系结构非常容易扩展，但也特别难以管理 ​ 混合体系结构 应用层协议原理 ​ 不同主机上的进程之间通信的规则 应用层协议定义了 ​ 交换的报文类型 ​ 各种报文类型的语法 ​ 字段的语义 ​ 进程何时、如何发送报文及对报文进行响应 使用传输层协议 ​ TCP ​ 面向连接: 在客户端和服务器进程之间需要建立连接 ​ 可靠传输:在发送和接受进程之间 ​ 流量控制: 发送数据的速度决不超过接收的速度 ​ 拥塞控制: 当网络超负荷时，束紧发送端口，减缓发送速度 ​ 不提供: 实时性, 最小带宽承诺 ​ UDP ​ 在客户端和服务器进程之间实现“不可靠的”数据传输 ​ 不提供:连接建立, 可靠性保证,流量控制,拥塞控制,实时性, 最小带宽承诺 每个网络应用进程都有一个属于自己的套接字，该套接字在整个因特网上独一无二，进程通过套接字来接收和发送报文 套接字相当于一个通道 ​ 发送进程将报文交给套接字 ​ 套接字将这些报文传输到接收进程的套接字 重点讨论的网络应用 WEB 文件传输 电子邮件 目录服务 P2P ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"2.2WEB和HTTP WEB的构成 ​ WEB服务器：IIS、Apache、TomCat…… ​ 浏览器：IE、Maxthon、Firefox ​ 协议 ​ 信息表达的协议——HTML ​ web内容表达：web页面由对象组成，任何对象可以用URL来定位 ​ 信息传输的协议——HTTP ​ C/S模式 ​ http1.0: RFC 1945 ——非持久性连接：取对象需要2RTTs 建立TCP连接、对象请求传送 ​ http1.1: RFC 2068 ——持久连接：建立TCP后不立即断开 非流水线方式：一个对象传输完成方能传输下一个 流水线方式：可以一次性发送所有请求，慢慢接收 ​ http使用TCP传输，端口号为80 ​ 特别说明：WEB属于C/S模式 HTTP请求报文 一段典型的HTTP报文 HTTP报文格式 HTTP1.0 定义的方法 GET ​ 向服务器请求指定URL的对象 POST ​ 用于向服务器提交表单数据 ​ 也可以同时请求一个WEB页面 ​ 特别注意：可以不使用POST方法，而使用GET方法发送表单数据以获取新的WEB页面。e.g. 搜索引擎 HEAD ​ 请求服务器返回一个响应报文，但是该报文中并不包含请求的对象。该方法常常用来进行故障跟踪。 HTTP1.1新定义的方法 PUT ​ 上传的文件放在实体主体字段中，目标路径由URL字段标明 DELETE ​ 删除URL字段中指定的文件 HTTP响应报文 一段典型的HTTP响应报文 HTTP响应报文的一般格式 常见的HTTP响应状态码和短语 200 OK ​ 请求成功, 被请求的对象在报文中 301 Moved Permanently ​ 被请求的对象被移动过, 新的位置在报文中有说明 (Location:) 400 Bad Request ​ 服务器不懂请求报文 404 Not Found ​ 服务器上找不到请求的对象 505 HTTP Version Not Supported ​ 服务器不支持请求报文使用的HTTP协议版本 用户服务器交互：Cookie WEB站点使用Cookie的目的 ​ 限制用户的访问 ​ 把内容和用户身份关联起来 Cookie技术的组成部分: ​ 在HTTP响应报文中有一个Cookie首部行 ​ 在HTTP请求报文中也有一个Cookie首部行 ​ 在用户的端系统中保留了一个Cookie文件，由用户浏览器负责管理 ​ 在Web站点有一个后端数据库 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:2:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第三章 运输层 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.1 概述和运输层服务 运输层的功能 ​ 为不同主机上运行的应用进程之间提供逻辑通信(logical communication) 运输层协议的工作内容 ​ 发送方：把应用数据划分成报文段(segments),交给网络层 ​ 接收方：把报文段重组成应用数据，交付给应用层 因特网上的运输层协议 用户数据报协议UDP（数据报） 传输控制协议TCP（报文段） 所提供的服务 ​ 进程间数据交付 ​ 差错检测 ​ 可靠的数据传输 ​ 拥塞控制 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.2 多路复用与多路分解 多路复用和多路分解是所有计算机网络都需要的。 多路复用:将运输层报文段中的数据交付到正确的套接字的工作，即从同一台主机上的不同Socket接收数据的过程 多路分解:在源主机从不同套接字中收集数据块并为每个数据块封装上首部信息从而生成报文段，然后将报文段上传到网络层的工作，即向同一台主机上的不同Socket传输数据的过程称为多路分解 传输层和应用程序进程之间通过Socket（套接字）关联，每个套接字都有一个唯一的ID，被称为端口号，端口号大小在0-65535之间，其中0-1023属于周知端口号，它们为特定的Socket而拥有。 无连接的多路复用与多路分解 创建的套接字具有主机本地端口； 一个UDP套接字是由一个目的IP地址和目的端口号即二元组来标志的； 当主机接收到UDP段：检查报文段目的地端口；将UDP报文段发送给端口号的套接字 如果两个UDP报文段有不同的源IP地址或者源端口号，但是有相同的目的IP和目的端口号的话，它们将通过同一个Socket到达同一个应用程序 面向连接的多路复用与多路连接 TCP协议中的Socket是通过一个四元组来标记的：（源IP地址，源端口号，目的IP地址，目的端口号）； 服务器主机同时支持多个并发的TCP套接字:每一个套接字都由其四元组来标识 Web服务器为每一个客户连接都产生不同的套接字 非持久HTTP对每一个请求都建立不同的套接字（会影响性能） 两个具有不同源IP地址或者源端口号，但有相同的目的IP地址和目的端口号的TCP报文段将通过两个不同的Socket进入同一应用进程； 一个应用进程可以关联多个Socket，而一个Socket将只关联一个应用进程；这样的对应关系是通过线程来实现的：一个进程有多个线程，而每个线程关联了一个Socket；这样做可以提高服务器性能。 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.3 无连接传输 : UDP 一个最简单的运输层协议即UDP必须提供 ​ 多路复用/多路分解服务 ​ 差错检查 UDP处理数据的流程 ​ 发送方 ​ 从应用进程得到数据 ​ 附加上为多路复用/多路分解所需的源和目的端口号及差错检测信息，形成报文段（数据报） ​ 递交给网络层，尽力而为的交付给接收主机 ​ 接收方 ​ 从网络层接收报文段（数据报） ​ 根据目的端口号，将数据交付给相应的应用进程 UDP的优势 ​ 无需建立连接——建立连接会增加时延 ​ 简单——发送方和接收方无需维护连接状态 ​ 段首部开销小——TCP:20Byte vs UDP:8Byte ​ 无拥塞控制——UDP 可按需要随时发送 UDP的检查和 目标 检测收到的报文段的“差错” (例如, 出现突变的比特) 发送方 把报文段看作是16比特字的序列 检查和：对报文段的所有16比特字的和进行1的补运算(最高有效位的进位要回卷加到结果当中) 发送方将计算校验和的结果写入UDP校验和字段中 接收方 计算接收到的报文段的校验和 检查计算结果是否与收到报文段的校验和字段中的值相同 不同 — 检测到错误 相同 — 没有检测到错误(但仍可能存在错误) ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:3","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.4 可靠数据传输的原理 可靠信道上的可靠传输—— rdt 1.0 底层信道完全可靠 不会产生比特错误 不会丢失分组 分别为发送方和接收方建立FSM 发送方将数据发送给底层信道 接收方从底层信道接收数据 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-Orig72RK-1606530179679)(D:\\素材\\image-20201124110604123.png)] 信道可能导致比特出现差错时——rdt 2.x 第一个版本——rdt 2.0 假设 分组比特可能受损 所有传输的分组都将按序被接收，不会丢失 处理机制 如何判断分组受损——差错检测 如何通知发送方分组是否受损——接收方反馈（ACK和NAK） 在得知分组受损后，发送方如何处理——出错重传 第二个版本——rdt 2.1 问题的引入：ACK和NAK分组可能受损，而rdt 2.0没有考虑该情况 第三个版本——rdt 2.2 针对rdt 2.1的改进 ​ 只使用ACK ​ 取消NAK，接收方对最后一个正确收到的分组发送 ACK ​ 接收方必须明确指出被确认的分组的序号 ​ 发送方收到的重复的ACK将按照NAK来进行处理 ​ 重传正确的分组 信道不但出错，而且丢包时——rdt 3.0 因为分组序号在 0 和 1 之间交替，因此 rdt 3.0 有时被称为 比特交替协议。 rdt3.0吞吐率低—-\u003e流水线技术—-\u003eGBN与SR协议 Go-Back-N协议 特点 ACK(n): 接收方对序号n之前包括n在内的所有分组进行确认 - “累积 ACK” 对所有已发送但未确认的分组统一设置一个定时器 超时(n): 重传分组n和窗口中所有序号大于n的分组 失序分组: 丢弃 (不缓存) -\u003e 接收方无缓存! 重发按序到达的最高序号分组的ACK Go-Back-N的滑动窗口大小 发送端 ≤ 2^k^-1 接收端 ＝ 1 选择重传（SR）协议 发送方: 从上层收到数据 : 如果下一个可用于该分组的序号在窗口内，则将数据打包并发送 超时(n): 重传分组n, 重置定时器 收到确认(n) 在 [sendbase,sendbase+N-1]范围内 标记分组 n 为已接收 如果n是发送窗口基序号sendbase，则将窗口基序号前推到下一个未确认序号 接收方 分组序号n在[rcvbase, rcvbase+N-1]范围内 发送n的确认ACK(n) 如果分组序号不连续(失序)：将其缓存 按序分组: 将该分组以及以前缓存的序号连续的分组一起交付给上层, 将窗口前推到下一个未收到的分组 分组序号n 在 [rcvbase-N,rcvbase-1]范围内： 虽然曾经确认过，仍再次发送n的确认ACK(n) 其他情况: 忽略该分组 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:4","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.5 面向连接的传输 : TCP TCP概述—RFCs：793、1122、1323、2581(2018年） 面向连接 全双工服务 点对点连接 可靠有序的字节流 流量控制 拥塞控制 流水线 TCP报文段首部结构 序列号： 在报文段数据中第一个字节在字节流中的编号 确认ack： 期待得到的下一个字节的seq ACK累积 超时重传间隔: ​ 估算RTT： ​ 估算偏差： ​ 超时间隔: TCP编号采用按字节编号，而非按报文段编号 TCP仅采用唯一的超时定时器 快速重传: 在超时到来之前重传报文段 如果发送收到一个数据的3个重复ACK，它会认为确认数据之后的报文段丢失 超时间隔加倍:超时事件发生后，TCP重传，会将TimeoutInterval加倍； 定时器在收到上层应用数据或收到ACK后，TimeoutInterval变为由EstimatedRTT与DevRTT估算得到。 TCP流量控制：接收方应用进程从缓冲区中读取数据可能很慢，为了防止发送方不会由于传得太多太快而使得接收方缓存溢出，所以当接收方在反馈时，将缓冲区剩余空间的大小填充在报文段首部的窗口字段中，通知发送方。 接收方窗口大小计算: TCP连接建立/断开(三次握手四次挥手): ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:5","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.6 拥塞控制原理 拥塞原因与代价: ​ 网络中的分组太多，而链路带宽和路由器缓存容量都是有限的 ​ 当分组的到达速率接近链路容量时，分组将经历巨大的排队时延； ​ 发送方必须执行重传已补偿因为缓存溢出而丢弃的分组 ​ 发送方遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。 ​ 当一个分组沿着一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了 拥塞控制方法 网络辅助的拥塞控制 直接网络反馈：路由器以阻塞分组的形式通知发送方“网络拥塞了” 经由接收方的网络反馈：路由器标识从发送方流向接收方分组中的某个字段以指示 拥塞的产生，由接收方通知发送方“网络拥塞了” 端到端拥塞控制 网络层不为拥塞控制提供任何帮助和支持 端系统通过对网络行为（丢包或时延增加）的观测判断网络是否发生拥塞 目前TCP采用该种方法 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:6","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"3.7 TCP拥塞控制 TCP发送方如何限制外发流量的速率 拥塞窗口 LastByteSent - LastByteAcked \u003c= min{CongWin，RcvWindow} 发送速率大概是： 发送方如何感知拥塞 ​ 超时 ​ 三个冗余ACK 在感知到拥塞后，发送方如何调节发送速率 TCP拥塞控制算法（Reno算法） 慢启动 建立连接时, CongWin = 1 MSS 例如: MSS = 500 bytes \u0026 RTT = 200 msec 初始速率 = 20 kbps 可用带宽 » MSS/RTT 初始阶段以指数的速度增加发送速率 连接初始阶段，以指数的速度（2倍）增加发送速率，直到发生一个丢包事件为止 每收到一次确认则将CongWin的值增加一个MSS 对收到3个重复ACK的反应——快速重传 门限值设为当前CongWin的一半（门限值初始值65kB） 将CongWin减为新的门限值+3MSS 线性增大拥塞窗口 对超时事件的反应 门限值(ssthresh)设为当前CongWin的一半（门限值初始值65kB） 将CongWin设为1个 MSS大小; 窗口以指数速度增大 窗口增大到门限值之后，再以线性速度增大 快速恢复（TCP推荐但非必须实现） ​ 3个冗余ACK进入快速重传后 ​ 每收到一个冗余ACK：CongWin++ ​ 直至收到一个新的ACK：CongWin=门限值，重新进入拥塞避免 ​ 在进入快速恢复之后及重新进入拥塞避免之间，如果出现超时现象，直接按照前述超时事件进行处理 ​ 额外说明 ​ 快速恢复和超时中，门限值并不总等于CongWin/2 ​ 门限值=Max(flightSize/2 , 2MSS) ​ flightsize:当时发送窗口中已发出但未确认的报文段数目 ​ 门限值=Max(min(拥塞窗口,通知窗口) , 2MSS) –微软 TCP吞吐量的进一步讨论 TCP吞吐量宏观描述:0.75 W/RTT 吞吐量是丢包率(L)的函数（经高带宽路径的TCP）: 对于一条MSS=1500字节，RTT=100ms的TCP连接而言，如果希望达到10Gbps的吞吐量，那么丢包率L不能高于2x10^(-10) TCP的公平性 公平性和UDP ​ 多媒体应用一般不使用 TCP ​ 不希望因为拥塞控制影响其速率 ​ 多媒体应用采用UDP: ​ 恒定的速率传输音频和视频数据，可容忍丢包 公平性和并行TCP连接 无法阻止应用在两个主机之间建立多个并行的连接. Web浏览器就是这样 例子: 速率为R 的链路当前支持9个并发连接; 应用请求一个TCP连接，获得R/10的速率 应用请求11个TCP连接，获得R/2的速率! ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:3:7","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第四章 网络层(数据平面) ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.1 网络层概述 网络层的目标 ​ 实现主机到主机的通信 网络层在计算机网络中的地位 ​ 为运输层提供支持 ​ 运输层实现进程到进程的通信 ​ 运输层功能的实现依赖于网络层提供的服务 ​ 为实现从源主机到目标主机成功的移动数据分组，整个路径上的每一台分组交换机上均需实现网络层 网络层的主要功能 ​ 在全局范畴为主机之间的通信进行选路，选路的结果反映为分组交换机上的转发表 ​ 分组交换机上的网络层根据转发表以及分组头部信息，将分组向适当链路进行转发 ​ 对于面向连接的网络层服务，提供连接建立的功能 ​ ATM、X.25和帧中继 ​ 转发(数据平面):当一个分组到达某路由器的一条输入链路时，该路由器必须将该分组移动到适当的输出链路。 ​ 路由选择(控制平面): 分组交换机的分类 ​ 根据链路层首部信息进行转发的——链路层节点交换机 ​ 根据网络层首部信息进行转发的——路由器 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"4.3 网际协议:IPv4、寻址、IPv6及其他 IP 数据报格式 版本号（IPv4、IPv6）：不同版本对数据报不同解释 首部长度：数据报可包含可变数量的选项。不过大部分没有，首部固定20字节 服务类型：区分不同类型的IP数据报 数据报长度：首部+数据的长度。该字段16bit，故理论上最大长度为65535字节，然而一般数据报很少超过1500字节。 标识、标志、片偏移：IP分片相关。不过IPv6不允许在路由器上对分组分片 寿命TTL：确保数据报不会永远在网络中循环。每被一个路由器处理时，值-1。若值减到0，丢弃数据报。 协议号：到达最终目的地才有用，指示了IP数据报的数据部分应该交给哪个运输层协议。如6交给TCP，如17交给UDP。协议号是将网络层与运输层绑定到一起的粘合剂；端口号是将运输层和应用层绑定的粘合剂 首部检验和：帮忙路由器检测收到IP数据报中首部的比特错误，有错一般丢弃。每台路由器上必须重新计算检验和。IP层仅对IP首部计算检验和，而TCP/UDP检验和是对整个TCP/UDP报文段进行的。 源和目的IP地址：源主机通常通过DNS查找目的地址 选项：IPv6已抛弃选项字段 数据（有效载荷）：包含运输层报文段（TCP或UDP），或ICMP报文段 一个IP数据报有长为20的首部，如果数据报承载一个TCP报文段，则每个无分片数据报承载总长40的首部（还有TCP的20）以及应用层报文 IP数据报分片 more 网络链路存在MTU (最大传输单元)—链路层数据帧可封装数据的上限不同链路的MTU不同 IPv4的设计者决定把数据报的重新组装工作放在端系统而不是路由器中。 大IP分组向较小MTU链路转发时， 可以被“分片” (fragmented) 1个IP分组分为多片IP分组 IP分片到达目的主机后进行“重组”(reassembled) IP首部的相关字段用于标识分片以及确定分片的相对顺序 总长度、标识、标志位和片偏移 假设原IP分组总长度为L，待转发链路的MTU为M 若L\u003eM，且DF=0，则可以/需要分片 分片时每个分片的标识复制原IP分组的标识 通常分片时，除最后一个分片，其他分片均分为MTU允许的最大分片 最后一个片的标志为0，其余的为1. 例： 4000字节的数据报，在MTU1500字节的链路上 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pjyaFjnQ-1606530179688)(D:\\素材\\20190326135559160.png)] 数据报的有效载荷仅当在IP层已完全重构为初始IP数据报时，才会传递给目的地传输层。如果一个或多个片没有到达目的地，则该不完整的数据报被丢失。 并不是所有链路层协议都能承载相同长度的网络层分组，如以太网帧能承载不超过1500字节的数据，某些广域网链路帧不超过576字节 一个链路层帧承载的最大数据量：最大传送单元MTU 限制了IP数据报的长度，且发送方与目的路径上的每段链路可能使用不同的链路层协议，有不同的MTU。 1）如何将过大的IP分组压缩进链路层帧的有效载荷字段？ 将IP数据报中的数据分片成多个较小的IP数据报，用单独的链路层帧封装这些小IP数据报，每个小数据报叫片 IPv4将数据报的重新组装放在端系统中，而不是路由器中 标识、标志、片偏移字段，帮助主机执行重组任务 一个4000字节的数据报（20+3980）到达一台路由器，转发到一条MTU为1500子节的链路上。必须分配3个独立的片，假设初始数据报的标识号是777，则前两片字节都为20+1480，第三层为20+1020 IPv6废除了分片，简化了IP分组的处理 IPV4编址 主机与路由器连入网络的方法 ​ 一台主机通常只有一条链路连接到网络，主机IP发送数据报从该链路发送 ​ 主机与物理链路的边界叫接口，一台路由器有多个接口 ​ IP要求每台主机和路由器都有自己的IP地址，因此一个IP地址实际上是与每一个接口相关联的 ​ 每个IP地址长度32bit（4字节），总共2^32个可能的IP地址，约40亿个 ​ 点分十进制记法，如193.32.216.9 ​ 一个接口的IP地址的一部分需要由其连接的子网决定.如互联3个主机接口与1个路由器接口的网络形成一个子网，IP编址为这个子网分配一个地址：223.1.1.0/24，/24记法称为子网掩码，指示了32bit中的最左侧24bit定义了子网地址 ​ 为了确定子网，分开主机和路由器的每个接口，产生几个隔离的网络岛，使用接口端接这些隔离的网络的端点，这些隔离的网络中每一个都叫做一个子网 ​ 因特网地址分配策略：无类别域间路由选择CDIR ​ a.b.c.d/x的地址的x最高比特构成IP地址的网络部分，称为该地址的前缀，一个组织通常被分配一块连续的地址，即具有相同前缀的一段地址。BGP路由选择协议中，该组织网络外的路由器仅考虑x，减少了转发表的长度，因为形式为a.b.c.d/x单一表项足以将数据报转发到该组织内的任何目的地 地址聚合（路由聚合）：使用单个网络前缀通告多个网络的能力 ​ 一个ISP将8个组织连接到因特网。该ISP向外界通告：向我发送以200.23.16.0/20开始的任何内容。外部无需知道在该地址块内还有8个其他组织，每个组织有自己的子网 一个地址的剩余32-x比特可认为是用于区分该组织内部设备的。组织内部路由器转发分组时，才会考虑这些比特 在CDIR出现之前，采用分类编址，A、B、C类网络，分别具有8、16、24比特子网地址 ​ E类：240.0.0.0~255.255.255.255 ​ D类 224.0.0.0~239.255.255.255 ​ C类（/24）仅能容纳2^8-2=254台主机（其中两个用于特殊用途）192.0.0.0~223.255.255.255 B类（/16）支持65534台主机，一个组织分配一个B类地址却只用2000个接口，造成巨大浪费 128.0.0.0~191.255.255.255 A类 （/8）0.0.0.0~127.255.255.255 IP广播地址 当一台主机发出目的地址为255.255.255.255的数据报时，报文会交付给同一个网络的所有主机，路由器也会有选择的向邻近的子网发送报文（通常不这样做）。可用于DHCP发现报文的发送，广播最小生成树 如何获取地址、分配地址？ 1. 获取一块地址 子网获取IP地址：由ISP从它大块地址中分配 ISP获取IP地址：IP地址由因特网名字和编号分配机构ICANN管理（也管理DNS根服务器、AS标识号）。ICANN向区域性因特网注册机构分配地址，处理本地域内的地址分配/管理 2.获取主机地址 组织获得一块地址，就可为组织内的主机、路由器接口逐个分配IP地址 主机地址能手动配置，也能自动配置，即动态主机配置协议DHCP 3.动态主机配置协议DHCP—UDP DHCP允许主机自动获取一个IP地址 DHCP可配置，可以使主机每次连网获得相同IP地址，也可每次分配一个临时IP地址。 DHCP还允许主机查看子网掩码、默认网关（第一跳路由器地址）、本地DNS服务器地址 DHCP能将主机连接进一个网络的自动能力，常被称为即插即用协议 DHCP是一个客户-服务器协议。新来的主机要获得自使用的IP地址等网络配置信息 每个子网都有一台DHCP服务器 若子网没有DHCP服务器，则由一个路由器做DHCP中继代理，该代理知道该网络的DHCP服务器地址 新主机到来时，DHCP协议的四个步骤 ​ 1.DHCP服务器发现 ​ 新到的客户通过广播DHCP发现报文，发现一个要与其交互的DHCP服务器 ​ 客户在UDP分组中向端口67发送该发现报文，此时必须用广播地址255.255.255.255，源地址是0.0.0.0 ​ 2.DHCP服务器提供 ​ DHCP收到DHCP发现报文后，响应一个DHCP提供报文，仍然使用广播地址，因为此时新客户并没有IP地址 ​ 可能有多台DHCP服务器，每台服务器提供的报文中，有向客户主机推荐的IP地址、网络掩码以及IP地址租用期（一般几天或几小时） ​ 3.DHCP请求 ​ 客户从提供中选一个，向选中的服务器提供一个DHCP请求报文进行响应，回显配置参数 ​ 4.DHCP ACK ​ 收到DHCP请求报文后，用DHCP ACK报文对其记性响应，证实所传参数 ​ 客户收到ACK后，交互完成，在租期内使用DHCP分配的IP地址。DHCP提供了机制允许客户更新对一个IP地址的租用 当一个移动结点在子网之间移动时，就不能维持与远程应用的TCP连接。 DHCP协议并不仅仅只能获取IP地址 网关地址 DNS地址 子网掩码 网络地址转换NAT 地址10.0.0.0/8是保留的3个IP地址空间之一，这些地址用于家庭网络等专用网络或具有专用地址的地域。具有专用地址的地域是指其地址仅对还网络中的设备有意义的网络。 当ISP已经为SOHO网络当前地址范围分配过一块连续地址，而SOHO内主机越来也多时，需要用到NAT（比如电信给你家分配一个动态IP地址，家里要好几台手机电脑联网用一个IP地址，需要用NAT）。 ​ NAT使能路由器 ​ NAT路由器对外界来看像一个具有单一IP地址的单一设备。例如，家里有一个NAT使能路由器，其IP地址138.76.29.7，且进入和离开家庭的报文都有同样的该地址 ​ NAT路由器对外隐藏了家庭网络的细节 ​ NAT路由器从ISP的DHCP服务器得到它的地址，并且路由器运行一个DHCP服务器，为位于NAT-DHCP路由器控制的家庭网络地址空间中的主机提供地址 实现 发送数据报: 将每","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:4:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第五章 网络层(控制平面) ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"5.1 概述 转发表和流表的计算、维护和安装： ​ 每台路由器控制:路由器选择算法 ​ 逻辑集中式控制 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"5.2 路由选择算法 几个概念 ​ 默认路由器：一台主机“直接”连接到的路由器 ​ 源路由器：源主机的默认路由器 ​ 目的路由器：目标主机的默认路由器 根据信息是全局性还是分散式的进行分类 全局选路算法 ​ 所有路由器都知道整个网络拓扑图以及链路的费用信息 ​ 链路状态算法（LS算法） 分散式选路算法 ​ 每个路由器仅有与其相连链路的费用信息 ​ 通过迭代计算过程与相邻节点交换信息 ​ 距离向量算法（DV算法） 根据信息是静态还是动态的进行分类 静态选路算法 随着时间的流逝，路由的变化非常缓 动态选路算法(更容易受选择循环和路由震荡影响) 路由信息可以更快地发生变化 周期性的更新 可以响应拓扑或链路费用的变化 还可以根据是否负载敏感和负载迟钝划分(链路开销是否明确反映当前的拥塞水平)为负载敏感算法和负载迟钝算法(如RIP、OSPF与BGP) LS算法——Dijkstra’s（迪克斯特拉）算法 所有节点都知道网络拓扑和链路费用 通过链路状态广播获得信息 所有节点具有该网络的同一个完整的视图 计算从某节点到网络中所有其他节点的最低费用 为该节点提供转发表 迭代: 经算法的K次迭代后，可知道到K个目的节点的最低费用路径 c(x,y): 从节点x到节点y的链路费用; 如果x和y不是直连的，则 c(x,y) = ∞ D(v): 随着算法进行本次迭代，从源节点到目的v的最低费用路径的费用 p(v): 从源节点到v沿着当前最低费用路径的前一节点 N‘: 节点子集。v在N‘中，如果从源节点到路径的最低费用路径已知 1 Initialization: 2 N' = {u} 3 for all nodes v 4 if v adjacent to u 5 then D(v) = c(u,v) 6 else D(v) = ∞ 7 8 Loop 9 find w not in N' such that D(w) is a minimum 10 add w to N' 11 update D(v) for all v adjacent to w and not in N' : 12 D(v) = min( D(v), D(w) + c(w,v) ) 13 /* new cost to v is either old cost to v or known 14 shortest path cost to w plus cost from w to v */ 15 until all nodes in N' Dijkstra’s（迪克斯特拉）算法的复杂性 ​ 对于第一次迭代: 需要搜索所有的n个节点以确定出节点w，w不在N’中且具有最低费用 ​ 在所有迭代中需要搜索的节点总数为n(n+1)/2 ，所以链路状态算法在最差情况下复杂性为 O(n2) ​ 该算法的一种更复杂的实现，使用一种叫做堆的数据结构，其计算复杂性为 O(mlogn) 拥塞敏感路由选择的震荡解决的方案 ​ 强制链路费用不依赖于所承载的流量 ​ 无法解决高拥塞的问题，不可接受 ​ 确保所有的路由器不同时运行LS算法 ​ 因特网上的路由器能够自同步 ​ 随机化路由器发送链路通告的时间 距离向量选路算法 特点：迭代、分布、自我终止、异步 思想 B-F公式：dx(y)=minv{c(x,v)+dv(y)} 每个路由器中都有一张路由表，包含三个内容：目的网络号、经过的邻居路由器、距离 路由器定期向其邻居路由器传送路由表的拷贝 路由表的更新算法 路由器X得到相邻路由器Y的路由表，从而得知：Y到网络Z的最短距离为N 如果路由器X没有到网络Z的路由条目，则添加一条经由路由器Y到网络Z距离N+1的路由条目 如果路由器X已有到网络Z的路由条目，其距离为M，如果M\u003eN+1，则更新该条目为经由路由器Y到网络Z距离N+1，否则不更新 链路状态改变时的特点 好消息传的快 在 t0 时刻, y 检测到链路费用变化, 更新自己的距离向量, 同时将这个变化通知给它的邻居 在 t1时刻, z 收到来自 y 的更新报文并更新了自己的距离向量表，计算出到x的新的最低费用，并向邻居发送它的新距离向量 在 t2时刻，y 收到自z的更新并更新其距离向量表，Y的最低费用未变，因此y不发送任何报文给z 坏消息传播的慢 无穷计数 路由环路 解决方案——毒性逆转 如果z通过y选路到达目的地x : z将通告y，它到x的距离是无穷大 (所以 y不会通过z到达x) 毒性逆转没有解决一般不可记数问题(三个或更多结点的环路无法检测)！ 链路状态路由选择算法 vs 距离向量路由选择算法 报文的复杂性 LS: n 个节点, E 条链路,需要发送 O(nE)个报文 DV: 只在直连的邻居之间交换报文 收敛速度 算法收敛时间依赖于许多因素，因而是可变的 LS: 是一个要求O(nE)个报文的O(n2) 算法 可能有震荡 DV: 收敛时间不确定 可能会遇到选路环路 记数到无穷问题 健壮性 LS: 节点能够向其连接的链路广播不正确费用 每个节点只计算自己的转发表 DV 一个节点可向任意或所有目的节点通告其不正确的最低费用路径 每个节点的计算都会传递给它的邻居 错误会通过网络进行传播 因特网上的距离向量算法——RIP协议 ​ 相邻两点间链路上的费用定义为1，即只考虑源到目标经过多少个路由器，或多少“跳” ​ 一条路径的最大费用限制为15 ​ 选路更新消息每30s在邻居之间以RIP响应报文（RIP通告）的形式进行交换 ​ 路由器经过180s没有收到来自某个邻居的RIP通告，则认为该邻居已离线，修改选路表，向其它邻居广播 ​ RIP是一个运行在UDP上的应用层协议（端口520） ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"5.3 因特网中自治系统内部的路由选择 层次路由 问题背景 因特网规模过大——数亿个目标网络 路由器无法存储每台主机的选路信息 路由表更新的报文广播将导致无剩余带宽供发送数据使用 管理自治 因特网 = 网络的网络 每个网络管理员可能希望能够按照自己的愿望运行和管理其网络 解决方法 将路由器聚合到一个区域, “自治系统” (AS) 在相同AS内的路由器可全部运行同样的选路算法 自治系统内部选路协议 内部网关协议 IGP (Interior Gateway Protocol) 目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。 在不同AS内的路由器可以运行不同的自治系统内部选路协议 转发表是由AS内部选路算法和AS间选路算法共同决定的 AS内部选路算法为内部目的地址设置转发表信息 AS内部选路算法和AS间选路算法共同为外部目的地址设置转发表信息 因特网中的链路状态选路——OSPF协议 ​ “开放”表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。 ​ “最短路径优先”是因为使用了 Dijkstra 提出的最短路径算法SPF ​ OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是“最短路径优先”。 ​ 是分布式的链路状态协议。 ​ 三个要点 ​ 向本自治系统中所有路由器发送信息，使用的方法是洪泛法 ​ 发送的信息就是与本路由器相邻的所有路由器的链路状态 ​ 只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息 ​ 由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库 ​ 这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的 ​ OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点 ​ 不强制如何设置链路权值的策略，但提供对给定链路权值集合确定最低费用路径的机制 ​ 即使链路状态未发生变化，每30分钟广播一次链路状态,增加了健壮性 ​ 链路状态以OSPF通告的形式封装在OSPF报文中，由IP分组承载（协议号：89） ​ OSPF路由器之间的交换都是经过鉴别的（简单的、MD5的），以确认OSPF通告的真实性，防止伪造和篡改 ​ OSPF通告都是有序列号的，以防止重放攻击 ​ OSPF中支持多条具有相同费用的路径 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:5:3","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第六章 链路层和局域网 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.1 链路层概述 节点：主机和路由器 链路：沿着通信路径连接相邻节点的通信信道 有线链路 无线链路 帧：数据链路层的分组单元 链路层提供的服务 成帧 、链路访问 将数据加上头部和尾部，封装成数据帧 共享介质的信道访问 帧头部用MAC地址标识源和目的（不同于IP地址） 可靠传递 很少用于误码率低的链路（光纤、双绞线链路） 用于误码率高的链路（无线链路） 流量控制 在相邻的收发节点间限制流量 差错检测 信号衰减和电磁干扰噪声导致出错 接收方检测到错误存在： 给发送方发送信号要求重传或丢弃该数据帧 差错纠正 接收方检测和纠正帧中错误，不用重传 半双工和全双工 半双工时，链路两端的节点都能传输分组，但不能同时传输 链路层的实现：在每一台设备上（主机、交换机、路由器），链路层在“适配器”（网卡NIC）或者芯片上实现，直接与主机的系统总线相连，是硬件、软件和固件的结合体。 适配器通信 发送方 在一个帧内封装数据报 增加差错检测位，可靠交付，流量检测等 接收方 查找错误,可靠交付, 流量控制等 取出数据报，交给网络层 适配器是半自治单元 帧的接收和发送、检错、丢弃均是自主进行 向上提交数据时，需要节点干预 最终受控于节点 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.2 差错检测和纠正技术 差错检测不是100%可靠的，EDC(差错检测和纠错比特)越长，责出错的概率越低 单比特奇偶校验、二位奇偶校验(略) 因特网检查和:仅应用与TCP、UDP和IPv4协议中 循环冗余校验码(广泛应用，如以太网、802.11WiFi与ATM) ​ 比特的数据，D ​ 选择r＋1比特模式(生成多项式)，表示为G ​ 目标：选择r个CRC比特，R，以便 ​ \u003cD,R\u003e恰好能被G整除（模2计算） ​ 接收方已知G，用G去除\u003cD,R\u003e ，若余数非0，则检测到错误 ​ 能检测到所有少于r+1比特的错误 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.3 多路访问链路协议 点到点链路:PPP/以太网交换机和主机之间的点到点链路 广播链路:传统以太网/HFC/802.11无限LAN ​ 单个共享广播信道 ​ 两个或多个节点同时传输:相互干扰 ​ 碰撞：一个节点同时收到两个或多个信号 多址访问协议 分布式算法决定节点如何共享信道，如节点何时可以传输数据 特别注意：有关共享信道的通信（协商）需使用信道本身 没有额外的信道来进行协调 理想的多址访问协议需满足： 假定：信道为速率为R b/s的广播信道 当只有一个节点有数据发送时，该节点的吞吐量为R 当M个节点有数据发送时，每个节点吞吐量为R/M 全分散控制 没有特定节点用于调整传输 没有时钟同步 简单 多址访问协议分类 信道划分协议 将信道划分成小的“片”（时隙、频率、编码） 将“片”分配给节点使用 随机访问协议 信道没有被分割，允许碰撞 碰撞恢复 轮流协议 节点轮流传送，但数据量大的节点轮流更长时间 信道划分协议 TDMA：循环访问信道；每个节点在每次循环中得到固定长度的时隙（时隙长度＝传输单个分组时间）；没有数据发送的时隙空闲 FDMA：信道按频谱分成若干频段；每个节点分配固定频段；在频段不用时该部分信道被闲置和浪费 (在重负荷时，共享信道有效、公平;在轻负荷时效率低：信道访问延时，即使只有一个活动节点，也只能分配到1/N的带宽) 随机访问协议：一个传输节点总是以信道的全部速率进行发送，当有碰撞时涉及碰撞的每个节点反复重发直到该帧无碰撞(历经碰撞时等待一个随机时延)。 时隙ALOHA，最大效率为1/e 纯ALOHA，最大效率为1/（2e） 载波侦听多路访问CSMA（传输前监听，空闲则传送，否则推迟传送）： ​ 非坚持(nonpersistent)CSMA 一旦监听到信道忙（即发现有其他站在发送数据），就不再坚持听下去，而是根据协议的算法延迟一个随机的时间后重新再监听。若进行载波监听时发现信道空闲，则将准备好的帧发送出去。——不能充分利用信道刚刚转入空闲期的这段时间。 ​ 时隙非坚持CSMA 采用划分时隙的随机接入CSMA协议，协议规定只能在每个时隙开始时才能发送帧。 ​ 1坚持CSMA ​ 当一个站点要传送数据时，首先侦听信道，看是否有其他站点正在传送。如果信道正忙，它就持续等待直到它侦听到信道空闲时，便将数据送出。若发生冲突，站点就等待一个随机长的时间，然后重新开始。——容易在上述这段时间产生冲突。 ​ P坚持CSMA ​ 当一个站点要传送数据时，首先侦听信道，看是否有其他站点正在传送。如果信道正忙，它就持续等待直到它侦听到信道空闲时，以概率P发送数据，而以概率（1－P）延迟一段时间τ(网络中最远的端到端的传播时延)，重新监听信道。若发生冲突，站点就等待一个随机长的时间，然后重新开始。——可以在一定程度上克服这些缺点，但却很难选择一个能用于各种通信量强度的P值。所以在实际网络中常选择1坚持。 ​ 具有碰撞检测的载波侦听多路访问CSMA/CD 在短时间内碰撞被检测 在有线LANs中比较容易:测量信号强度，比较收、发的信号 在无线LANs中比较困难: 传输时接收器是关闭的 碰撞后停止传输，减少信道浪费 强化碰撞：当发送数据的站一旦发现发生了碰撞时，除了立即停止发送数据外，还要再继续发送若干比特的人为干扰信号(jamming signal)，以便让所有用户都知道现在已经发生了碰撞。 争用期:最先发送数据帧的站，在发送数据帧后至多经过时间 2τ（两倍的端到端时延）就可知道发送的数据帧是否遭受了碰撞。以太网的端到端往返时延 2τ称为争用期，或碰撞窗口。经过争用期这段时间还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 （轻负荷时效率高：只有一个节点时，能充分利用信道；在重负荷下: 碰撞的开销） 轮流协议 ​ 轮询协议(如蓝牙协议、802.15协议):节点之一被指定为主节点，主节点以循环的方式轮询每个节点。其缺点是引入了轮询时延和主节点失效则信道失效的问题。 ​ 令牌传递协议(FDDI、IEEE 802.5):称为令牌的小的特殊帧在节点之间以某种固定的次序交换。一个结点仅当有一些帧要发送时持有令牌，否则立即把令牌教给下一个节点。其缺点是有令牌的开销，以及一个节点的故障可能会使整个信道崩溃。 DOCSIS:用于电缆因特网接入的链路层协议 每个信道的下行吞吐量为40Mbps 每个信道的上行吞吐量在30 Mbps FDM 应用在上行和下行的频率通道上 TDM 上行: 一些时隙被使用, 一些时隙有碰撞 下行信道发送 MAP 帧: 配置下行时隙 电缆乔治解调器在选定的时隙中以随机接入的方式进行传输，没有在下一个下行控制报文中收到请求分配的相应则推断出发生碰撞，它以二进制指数回退要求重新发送。 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:3","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.4 交换局域网 MAC地址（链路层地址，又称为LAN地址、物理地址） 作用 在数据链路层标识每块网络适配器，使得能够在广播信道上寻址目标节点 组成 48bit（e.g.: 1A-2F-BB-76-09-AD） 前24bit由IEEE分配管理——OUI号 后24bit由厂商自行分配 (MAC地址烧入网络适配器的ROM中，不可更改） (IP地址在不同的网络间迁移时，需要改变以适应新的网络配置,而MAC不会改变) 地址解析协议（ARP）——跨越链路层与网络层的协议 目标 根据目标的IP地址获取其MAC地址 ARP高速缓存 局域网节点的IP/MAC地址映射 \u003c IP; MAC;TTL\u003e TTL (Time To Live):超过TTL的地址映射会被删除 (一般为20分钟) 互联网下的ARP 以太网 最先被广泛应用的局域网技术 便宜 速度：10Mbps-\u003e100Mbps-\u003e1Gbps-\u003e10Gbps-\u003e200/400Gbps（2017/12/6 802.3bs） 以太网类型: ​ 总线式以太网 ​ 交换式以太网 以太网的帧结构 ​ 数据字段:（46字节，1500字节） ​ 前同步码: ​ 总共8字节，前7 字节的格式为 10101010 ，最后一个字节格式为10101011 用于同步发送方与接收方时钟 ​ 地址: 6 字节 ​ 若适配器收到以太网帧，目的地址为自己的MAC地址或广播地址（如ARP包），就将帧中的数据传给网络层。否则，适配器丢弃该帧。 ​ 类型: 上层协议类型 (大多为IP协议，也支持其它协议如Novell IPX 和AppleTalk) ​ CRC: 由接收方检查,若检测到错误，就将该帧丢弃 ​ 以太网提供的服务 ​ 无连接服务: 在送适配器和接收适配器之间不需要握手 ​ 不可靠服务: 接收适配器不发送确认帧或否认帧给发送方 ​ 交给网络层的数据报可能存在间隙 ​ 若应用使用TCP，间隙会被填充 ​ 否则，应用就会看见间隙 以太网使用的CSMA/CD 特点 没有时隙 当适配器侦听到其它适配器在传输，则它不传输帧, 即载波侦听 正在传输的适配器若检测到其它适配器也在传输，则它中止自己的传输, 即碰撞检测 在重新传输之前，适配器要等待一段随机时间，即随机回退 ​ 算法 ​ 适配器收到来自网络层的数据报，创建帧 ​ 若适配器检测到信道空闲，则开始传输帧；若检测到信道忙，就开始等待，直到信道空闲再开始传输该帧 ​ 若适配器传输了整个帧而没有检测到其它适配器的传输，则该适配器完成该帧的传输 ​ 若适配器在传输时检测到其它适配器也在传输，则停止传输，发送拥塞信号 ​ 中止传输后，适配器进入指数回退阶段，在经历第m次碰撞后，适配器随机从{0,1,2,…,2m-1}中选择K值。适配器在等待 K·512比特时间后，返回第2步 拥塞信号: 用来确保所有传输者都能检测到碰撞而传输的信号；48比特长 比特时间: 传输1比特所需时间。在10Mbps的以太网中，当K=1023时，等待时间大约为50ms 指数回退算法 目的: 适配器重传时试图估计正确的负载 重载: 随机等待的时间可能会更长 第一次碰撞: 从 {0,1}中选择K; 延迟是 K· 512 比特传输时间 第二次碰撞后: 从 {0,1,2, 3}中选择K 第十次碰撞后: 从 {0,1,2,3,4,…,1023}中选择K 重要特性 使用 CSMA/CD 协议的以太网不能进行全双工通信而只能进行双向交替通信（半双工通信）。 每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。 这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。 争用期长度 以太网取 51.2 μs 为争用期的长度。 对于 10 Mb/s 以太网，在争用期内可发送512 bit，即 64 字节。 以太网在发送数据时，若前 64 字节没有发生碰撞，则后续的数据就不会发生碰撞。 最短有效帧长 如果发生碰撞，就一定是在发送的前 64 字节之内。 由于一检测到碰撞就立即中止发送，这时已经发送出去的数据一定小于 64 字节。 以太网规定了最短有效帧长为 64 字节，凡长度小于 64 字节的帧都是由于冲突而异常中止的无效帧。 以太网交换机互联 交换机（Swtich）是一种存储—转发设备，在MAC层实现LAN互连 交换机的工作原理 ​ 不断监听各接口是否有信号 ​ 收到无差错的帧则缓存，反之将差错帧丢弃 ​ 若所收帧的目的MAC地址属另一网段，则通过站表决定向何接口转发 ​ 交换机不转发同一网段内通信的帧 ​ 交换机不修改所转发的帧的源地址 交换机的优势 过滤通信量 扩大了局域网的物理范围 提高了可靠性 可互连不同物理层、不同MAC子层和不同速率的局域网 交换机的缺点 由于要接收和转发，增加了时延 MAC子层没有流量控制功能，网络负荷重时，交换机缓存空间可能发生溢出，产生帧丢失现象 出现广播风暴。交换机只适合用户少于几百个和通信量不太大的局域网，否则有时会因传播过多广播信息而产生网络拥塞 交换机和集线器的区别 集线器只是将网络的覆盖距离简单的延长，而且距离有限，具体实现在物理层；交换机不仅具有将LAN的覆盖距离延长的作用，而且理论上可做到无限延长，具体实现在MAC层。 集线器仅具有简单的信号整形和放大的功能；交换机则属于一种智能互连设备，它主要提供信号的存储/转发、数据过滤、路由选择等能力。 集线器仅是一种硬设备，而交换机既包括硬件又包括软件。 交换机的透明性:指局域网上的每个站并不知道所发送的帧将经过哪几个交换机，即交换机对各站来说是看不见的 交换机选路原理 ① 从接口x收到帧，有差错则丢弃，否则在站表中查找目的站MAC地址； ② 找到有，则取出相应的接口d，转③，否则转⑤； ③ 如果所给MAC地址的接口d=x，则丢弃此帧（不需要转发），否则从接口d转发此帧； ④ 转到⑥； ⑤ 向除x以外的所有接口转发此帧（可保证找到目的站） ⑥ 如源站不在站表中，则将源站MAC地址写入站表，登记该帧进入交换机的接口号和时间，设置计时器，然后转⑧。否则转⑦； ⑦ 更新计时器（由于网络拓扑经常变化，因此，超时记录要删除，以反映最新状态）； ⑧ 等待新的数据帧。转① 以太网交换机 vs 路由器 两者都是存储转发设备 路由器：网络层设备 (检查网络层头部) 交换机是链路层设备 路由器维护路由表，实现路由算法 交换机维护交换表，实现MAC地址过滤、学习算法 [外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-oPZ65hM0-1606530179692)(D:\\素材\\image-20201125173908592.png)] 虚拟局域网 VLAN 局域网交换机是组建虚拟局域网的核心设备。 组成逻辑工作组的各结点不受物理位置的限制，换言之同一逻辑工作组的成员不一定要连接在同一个物理网段上。 当一个结点从一个逻辑工作组转移到另一个逻辑工作组时，只需要通过软件设定，而不需要改变它在网络中的物理位置。 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:4","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"6.7 回顾：Web页面请求的历程 略，见书 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:6:5","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"第七章 无线网络和移动网络 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:0","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.1 概述 无线特性：基于无线链路的通信 移动特性：移动用户的网络接入点是变化的 无线网络的元素: ​ 无线主机：便携机、PDA、IP电话等，本身固定或移动。 ​ 无线链路：用于连接无线主机和基站，有与链路访问匹配的多址访问协议。 ​ 基站：连接无线网络，向主机发送接收分组在无线网络和主机间起链路层中继作用（如蜂窝塔、802.11接入点） 无线局域网可分为有固定基础设施和自组网络(ad hoc网络) 基础设施模式：预先建立起来的、能够覆盖一定地理范围的一批固定基站。移动主机位于某个基站的无线通信覆盖范围内，通过基站接入有线网络; 切换:移动主机的移动可能会改变与之相关联的基站。 Ad hoc网络：无基站，节点向覆盖范围内其他节点传送数据，相互通信组成临时网络，在这些节点内部进行选路和地址分配。 几种标准无线网络标准的链路特性： ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:1","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.2 无线链路和网络特征 无线链路的特征 ​ 递减的信号强度、来自其他源的干扰、多径传播 由于这些特征，其比特差错比有线链路更常见，无线链路采用CRC进行帧校验并采用ARQ协议重传。 信号差错指标 ​ SNR——信噪比 ​ BER——比特差错率 对于给定的调制方案，SNR越高，BER越低 对于给定的SNR，具有较高比特传输率的调制技术将具有较高的BER 存在隐藏终端问题：存在障碍物、信号衰减 码分多址访问(CDMA):每一个站的码片序列各不相同、相互正交 ","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:2","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"categories":["学习笔记"],"content":"7.3 WiFi：802.11无线LAN 802.11协议簇概述 都是使用CSMA/CA 协议实现多路访问 都可以用于有固定基础设施模式和自组网络模式 802.11b 工作在不需要许可证的2.4~2.485 GHz的无线频谱上; 最高数据速率 11 Mbps 采用直接序列扩频(DSSS):所有主机使用相同的码片序列 802.11a 频率范围:5.1~5.8 GHz 最高数据速率: 54 Mbps 802.11g 2.4~2.485 GHz范围 最高数据速率 54 Mbps 802.11n：多天线 2.4~2.485、5.1-5.8GHz范围 单流最高数据速率 150Mbps 多流最高数据速率 600Mbps 802.11ac 5.1~5.8GHz范围 单流最高数据速率 433Mbps@80MHz信道带宽、866Mbps@160MHz信道带宽 多流最高数据速率1.73Gbps、3.47Gbps 第六代Wi-Fi：802.11ax 单流速率提升至1.2Gbps，8x8模式下提供高达9.6Gbps的传输速率 支持较窄的子载波间隔以及增加的符号持续时间，更有利于确保信号的健壮性，令Wi-Fi覆盖至更远范围 引入曾在4G LTE上使用的正交频分多址（OFDMA）技术，加之同时支持2.4GHz和5GHz频段，能创造出更多可用的数据通道，解决无线网络拥堵问题 通过在多AP多用户并发场景中引入很多LTE领域的组网特性，让信号的抗干扰性大幅提升 802.11体系结构 无线终端通过基站（AP）进行通信 基本服务集BSS包括 无线终端 基站AP Ad hoc模式下只有终端 802.11b的信道划分 2.4GHz—2.485GHz，共85MHz 划分为11个部分重叠的信道集 两个信道仅当中间相隔4个及以上的信道时，无重叠 1、6、11三个信道不重叠，可同时工作 802.11b中主机关联AP的过程 每个AP周期性发送信标帧，包括AP的SSID和MAC 主机对11个信道进行扫描，获取所有可用的AP的信标帧 主机选择其中一个AP发送关联请求帧，AP回以关联响应帧，主机加入该AP所属子网 主机向关联AP发送DHCP发现报文，获取IP地址 可能需要身份鉴别 （无线主机也可以执行主动扫描，自主机广播探测请求帧，AP发送探测相应，主机再进行关联请求……） 802.11的MAC协议——CSMA/CA ​ 使用碰撞避免而非碰撞检测:由于隐蔽终端和衰减的问题无法检测到所有的碰撞；碰撞检测要求站点同时有发送和接收的能力，802.11适配器上接收信号强度可能远小于发送信号的强度无法被检测，实现硬件代价大。 发送方的工作流程 如果侦听到信道闲置了DIFS(分布式帧间间隔) 秒，则传输整个帧 (无冲突检测) 如果侦听到信道忙，则选择一个随机避退值作为定时器的定时时间，并在侦听信道闲置时递减该值。 定时时间一到且信道空闲就发送整个数据帧 如果收到确认，且站点要继续发送数据帧，则执行第2步；如果没有收到确认（ ACK）,则在更大范围内选取随机值, 重复第2步。若干次重传后仍未收到确认时发送方丢弃该帧。 接收方工作流程 如果帧收到则OK，等待SIFS(短帧间间隔) 秒后返回ACK (ACK是必须的因为隐蔽站问题) 冲突避免 ​ 思路: 允许发送方“预约”信道而非随机访问 :避免长的数据帧冲突 ​ 发送方在发送数据帧之前首先使用 CSMA协议发送一个短的请求发送RTS( request-to-send)帧给AP： ​ RTS也可能仍会相互冲突 (但时间很短) ​ AP广播一个允许发送 CTS（clear-to-send）帧响应 RTS ​ RTS 被所有节点侦听到 ​ 发送方发送数据帧 ​ 其他站点推迟发送 使用短的预约帧可以完全避免数据帧发生冲突。 RTS/CTS交换引入了时延以及消耗信道资源，因此仅仅用于为长数据帧预约信道。 802.11MAC帧格式 ​ AP接收无线主机H1后将802.11帧转换成以太网帧时，源地址字段是H1的MAC地址(地址2)，目的地址字段是与AP相连的路由器R1的MAC地址(地址3)。 序号：使接收方区分新传输和以前帧的重传。 帧控制：扩展为协议版本、类型、子类、to/from、WEP等，其中类型和子类型字段用于区分RTS、CTS、ACK、数据帧，to/from用于定义不同地址字段的含义。 802.11同一子网内的移动性 ​ 主机与AP：一个无线主机H1从BSS1移动到BSS2，H1检测到AP1的信号逐渐减弱并检测一个更强的信号，收到AP2的信号，并与AP1解除关联，并与AP2关联起来，同时保持其IP地址和维持正在进行的TCP会话。 ​ 交换机：一种解决办法是，新关联形成后AP2以H1的源地址发送以太网广播帧，让交换机更新ARP表。 802.11速率自适应 ​ 基站和移动终端之间的速度会随着移动终端的移动和SNR的变化而智能的调整 1. 当终端向远离基站的方向移动时，SNR 减小, BER 增大 2. 当 BER 增大到一定程度时，将速率切换到一个较低的水平来保障较低的 BER 功率管理 ​ node-to-AP: “我将保持睡眠状态直到下一个信标帧”：通过将802.11帧守首部的功率管理比特置为1，节点向接入点指示它将进入睡眠模式 ​ AP 知道不应当向这个节点发送任何帧 ​ AP缓存所有需要发送给该节点的帧，待以后再传输 ​ 节点在下一个信标帧前唤醒 ​ 信标帧: 包含了帧被缓存在AP中的节点的列表 ​ 如果有帧，待发送节点会保持活动状态，向AP发送探询报文，请求这些缓存帧，再转入睡眠状态 ​ 如果没有帧，重新进入睡眠状态直到下一个信标帧前 802.15——无线个人区域网(蓝牙与ZigBee) ​ 半径小于 10 米 ​ 取代那些电缆 (鼠标, 键盘, 耳机) ​ 是自组网: 无固定基础设施 ​ 主/从式: ​ 从设备 请求允许向主设备发送； ​ 主设备同意请求。 ​ 802.15: 从蓝牙技术规范演变而来 ​ 2.4-2.5 GHz 无线电波段 ​ 最大数据速率 721 kbps 撞避免而非碰撞检测:由于隐蔽终端和衰减的问题无法检测到所有的碰撞；碰撞检测要求站点同时有发送和接收的能力，802.11适配器上接收信号强度可能远小于发送信号的强度无法被检测，实现硬件代价大。 发送方的工作流程 如果侦听到信道闲置了DIFS(分布式帧间间隔) 秒，则传输整个帧 (无冲突检测) 如果侦听到信道忙，则选择一个随机避退值作为定时器的定时时间，并在侦听信道闲置时递减该值。 定时时间一到且信道空闲就发送整个数据帧 如果收到确认，且站点要继续发送数据帧，则执行第2步；如果没有收到确认（ ACK）,则在更大范围内选取随机值, 重复第2步。若干次重传后仍未收到确认时发送方丢弃该帧。 接收方工作流程 如果帧收到则OK，等待SIFS(短帧间间隔) 秒后返回ACK (ACK是必须的因为隐蔽站问题) 冲突避免 ​ 思路: 允许发送方“预约”信道而非随机访问 :避免长的数据帧冲突 ​ 发送方在发送数据帧之前首先使用 CSMA协议发送一个短的请求发送RTS( request-to-send)帧给AP： ​ RTS也可能仍会相互冲突 (但时间很短) ​ AP广播一个允许发送 CTS（clear-to-send）帧响应 RTS ​ RTS 被所有节点侦听到 ​ 发送方发送数据帧 ​ 其他站点推迟发送 使用短的预约帧可以完全避免数据帧发生冲突。 RTS/CTS交换引入了时延以及消耗信道资源，因此仅仅用于为长数据帧预约信道。 802.11MAC帧格式 [外链图片转存中…(img-VkDFW3GC-1606530179693)] ​ AP接收无线主机H1后将802.11帧转换成以太网帧时，源地址字段是H1的MAC地址(地址2)，目的地址字段是与AP相连的路由器R1的MAC地址(地址3)。 序号：使接收方区分新传输和以前帧的重传。 帧控制：扩展为协议版本、类型、子类、to/from、WEP等，其中类型和子类型字段用于区分RTS、CTS、ACK、数据帧，to/from用于定义不同地址字段的含义。 802.11同一子网内的移动性 ​ 主机与AP：一个无线主机H1从BSS1移动到BSS2，H1检测到AP1的信号逐渐减弱并检测一个更强的信号，收到AP2的信号，并与AP1解除关联，并与AP2关联起来，同时保持其IP地址和维持正在进行的TCP会话。 ​ 交换机：一种解决办法是，新关联形成后AP2以H1的源地址发送以太网广播帧，让交换机更新ARP表。 802.11速率自适应 ​ 基站和移动终端之间的速度会随着移动终端的移动和SNR的变化而智能的调整 1. 当终端向远离基站的方向移动时，SNR 减小, BER 增大 2. 当 BER 增大到一定程度时，将速率切换到一个较低的水平来保障较低的 BER 功率管理 ​ node-to-AP: “我将保持睡眠状态直到下一个信标帧”：通过将802.11帧守首部的功率管理比特置为1，节点向接入点指示它将进入睡眠模式 ​ AP 知道不应当向这个节点发送任何帧 ​ AP缓存所有需要发送给该节点的帧，待以后再传输 ​ 节点在下一个信标帧前唤醒 ​ 信标帧: 包含了帧被缓存在AP中的节点的列表 ​ 如果有帧，待发送节点会保持活动状态，向AP发送探询报文，请求这些缓存帧，再转入睡眠状态 ​ 如果没有帧，重新进入睡眠状态直到下一个信标帧前 802.15——无线个人区域网(蓝牙与ZigBee) ​ 半径小于 10 米 ​ 取代那些电缆 (鼠标, 键盘, 耳机) ​ 是自组网: 无固定基础设施 ​ 主/从式: ​ 从","date":"2021-01-22","objectID":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/:7:3","tags":["计算机网络"],"title":"计算机网络复习笔记","uri":"/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"}]